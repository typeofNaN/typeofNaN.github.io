<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组去重</title>
    <url>/2018/10/19/array-remove-repetition/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此文介绍数组去重方法。</p>
<a id="more"></a>
<h1 id="一、利用ES6-Set去重（ES6中最常用）"><a href="#一、利用ES6-Set去重（ES6中最常用）" class="headerlink" title="一、利用ES6 Set去重（ES6中最常用）"></a>一、利用ES6 Set去重（ES6中最常用）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"> <span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;&#125;, &#123;&#125;]</span></span><br><span class="line"> <span class="comment">// 不考虑兼容性，这种去重的方法代码最少。这种方法还无法去掉“&#123;&#125;”空对象，后面的高阶方法会添加去掉重复“&#123;&#125;”的方法。</span></span><br></pre></td></tr></table></figure>
<h1 id="二、利用for嵌套for，然后splice去重（ES5中最常用）"><a href="#二、利用for嵌套for，然后splice去重（ES5中最常用）" class="headerlink" title="二、利用for嵌套for，然后splice去重（ES5中最常用）"></a>二、利用for嵌套for，然后splice去重（ES5中最常用）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[i] == arr[j]) &#123;    <span class="comment">// 第一个等同于第二个，splice方法删除第二个</span></span><br><span class="line">        arr.splice(j, <span class="number">1</span>);</span><br><span class="line">        j--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line"><span class="comment">// NaN和&#123;&#125;没有去重，两个null直接消失了</span></span><br><span class="line"><span class="comment">// 双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</span></span><br></pre></td></tr></table></figure>
<h1 id="三、利用indexOf去重"><a href="#三、利用indexOf去重" class="headerlink" title="三、利用indexOf去重"></a>三、利用indexOf去重</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.indexOf(arr[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line"><span class="comment">// NaN、&#123;&#125;没有去重</span></span><br><span class="line"><span class="comment">// 新建一个空的结果数组，for 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则push进数组。</span></span><br></pre></td></tr></table></figure>
<h1 id="四、利用sort"><a href="#四、利用sort" class="headerlink" title="四、利用sort()"></a>四、利用sort()</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  arr = arr.sort()</span><br><span class="line">  <span class="keyword">var</span> arrry = [arr[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] !== arr[i<span class="number">-1</span>]) &#123;</span><br><span class="line">      arrry.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [0, 1, 15, "NaN", NaN, NaN, &#123;…&#125;, &#123;…&#125;, "a", false, null, true, "true", undefined]</span></span><br><span class="line"><span class="comment">// NaN、&#123;&#125;没有去重</span></span><br><span class="line"><span class="comment">// 利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对。</span></span><br></pre></td></tr></table></figure>
<h1 id="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"><a href="#五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）" class="headerlink" title="五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"></a>五、利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> arrry = [];</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[arr[i]]) &#123;</span><br><span class="line">      arrry.push(arr[i])</span><br><span class="line">      obj[arr[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arrry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", 15, false, undefined, null, NaN, 0, "a", &#123;…&#125;]</span></span><br><span class="line"><span class="comment">// 两个true直接去掉了，NaN和&#123;&#125;去重</span></span><br></pre></td></tr></table></figure>
<h1 id="六、利用includes"><a href="#六、利用includes" class="headerlink" title="六、利用includes"></a>六、利用includes</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(arr)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'type error!'</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> array =[];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>( !array.includes( arr[i]) ) &#123;    <span class="comment">// includes 检测数组是否有某个值</span></span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]</span></span><br><span class="line"><span class="comment">// &#123;&#125;没有去重</span></span><br></pre></td></tr></table></figure>
<h1 id="七、利用hasOwnProperty"><a href="#七、利用hasOwnProperty" class="headerlink" title="七、利用hasOwnProperty"></a>七、利用hasOwnProperty</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;]</span></span><br><span class="line"><span class="comment">// 所有的都去重了</span></span><br><span class="line"><span class="comment">// 利用hasOwnProperty 判断是否存在对象属性</span></span><br></pre></td></tr></table></figure>
<h1 id="八、利用filter"><a href="#八、利用filter" class="headerlink" title="八、利用filter"></a>八、利用filter</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前元素，在原始数组中的第一个索引 == 当前索引值，否则返回当前元素</span></span><br><span class="line">    <span class="keyword">return</span> arr.indexOf(item, <span class="number">0</span>) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>
<h1 id="九、利用递归去重"><a href="#九、利用递归去重" class="headerlink" title="九、利用递归去重"></a>九、利用递归去重</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> array = arr;</span><br><span class="line">  <span class="keyword">var</span> len = array.length;</span><br><span class="line">  array.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;    <span class="comment">// 排序后更加方便去重</span></span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(array[index] === array[index<span class="number">-1</span>]) &#123;</span><br><span class="line">        array.splice(index,<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      loop(index - <span class="number">1</span>);    <span class="comment">// 递归loop，然后数组去重</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loop(len<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "a", "true", true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, undefined]</span></span><br></pre></td></tr></table></figure>
<h1 id="十、利用Map数据结构去重"><a href="#十、利用Map数据结构去重" class="headerlink" title="十、利用Map数据结构去重"></a>十、利用Map数据结构去重</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayNonRepeatfy</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>();    <span class="comment">// 数组用于返回结果</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(map.has(arr[i])) &#123;    <span class="comment">// 如果有该key值</span></span><br><span class="line">      map.set(arr[i], <span class="literal">true</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      map.set(arr[i], <span class="literal">false</span>);    <span class="comment">// 如果没有该key值</span></span><br><span class="line">      array.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> array ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "a", "true", true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, "NaN", 0, "a", &#123;…&#125;, undefined]</span></span><br><span class="line"><span class="comment">// 创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。</span></span><br></pre></td></tr></table></figure>
<h1 id="十一、利用reduce-includes"><a href="#十一、利用reduce-includes" class="headerlink" title="十一、利用reduce+includes"></a>十一、利用reduce+includes</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev,cur</span>) =&gt;</span> prev.includes(cur) ? prev : [...prev,cur],[]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'true'</span>, <span class="string">'true'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">'NaN'</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, &#123;&#125;, &#123;&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(unique(arr));</span><br><span class="line"><span class="comment">// [1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", &#123;…&#125;, &#123;…&#125;]</span></span><br></pre></td></tr></table></figure>
<h1 id="十二、-…new-Set-arr"><a href="#十二、-…new-Set-arr" class="headerlink" title="十二、[…new Set(arr)]"></a>十二、[…new Set(arr)]</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[...new <span class="built_in">Set</span>(arr)] </span><br><span class="line"><span class="comment">//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</span></span><br></pre></td></tr></table></figure>
<p>方法多种多样！</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>array</tag>
        <tag>repetition</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript</title>
    <url>/2020/03/03/ECMAScript/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会）在标准ECMA-262中定义的脚本语言规范。这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMA-262标准的实现和扩展。</p>
<a id="more"></a>
<h1 id="历史版本"><a href="#历史版本" class="headerlink" title="历史版本"></a>历史版本</h1><p>至发稿日为止有九个ECMA-262版本发表。其历史版本如下：</p>
<p>1.1997年6月：第一版<br>2.1998年6月：修改格式，使其与ISO/IEC16262国际标准一样<br>3.1999年12月：强大的正则表达式，更好的词法作用域链处理，新的控制指令，异常处理，错误定义更加明确，数据输出的格式化及其它改变<br>4.2009年12月：添加严格模式(“use strict”)。修改了前面版本模糊不清的概念。增加了getters，setters，JSON以及在对象属性上更完整的反射。<br>5.2011年6月：ECMAScript标5.1版形式上完全一致于国际标准ISO/IEC 16262:2011。<br>6.2015年6月：ECMAScript 2015（ES2015），第 6 版，最早被称作是 ECMAScript 6（ES6），添加了类和模块的语法，其他特性包括迭代器，Python风格的生成器和生成器表达式，箭头函数，二进制数据，静态类型数组，集合（maps，sets 和 weak maps），promise，reflection 和 proxies。作为最早的 ECMAScript Harmony 版本，也被叫做ES6 Harmony。<br>7.2016年6月：ECMAScript 2016（ES2016），第 7 版，多个新的概念和语言特性。<br>8.2017年6月：ECMAScript 2017（ES2017），第 8 版，多个新的概念和语言特性。<br>9.2018年6月：ECMAScript 2018 （ES2018），第 9 版，包含了异步循环，生成器，新的正则表达式特性和 rest/spread 语法。<br>10.2019年6月：ECMAScript 2019 （ES2019），第 10 版。</p>
<h1 id="发展标准"><a href="#发展标准" class="headerlink" title="发展标准"></a>发展标准</h1><p>TC39（Technical Committee 39）是一个推动JavaScript发展的委员会，它的成语来自各个主流浏览器的代表成语。会议实行多数决，每一项决策只有大部分人同意且没有强烈反对才能去实现。</p>
<p>TC39成员制定着ECMAScript的未来。</p>
<p>每一项新特性最终要进入到ECMAScript规范里，需要经历5个阶段，这5个阶段如下：</p>
<ul>
<li>Stage 0: Strawperson</li>
</ul>
<p>只要是TC39成员或者贡献者，都可以提交想法</p>
<ul>
<li>Stage 1: Proposal</li>
</ul>
<p>这个阶段确定一个正式的提案</p>
<ul>
<li>Stage 2: draft</li>
</ul>
<p>规范的第一个版本，进入此阶段的提案大概率会成为标准</p>
<ul>
<li>Stage 3: Candidate</li>
</ul>
<p>进一步完善提案细则</p>
<ul>
<li>Stage 4: Finished</li>
</ul>
<p>表示已准备好将其添加到正式的ECMAScript标准中</p>
<p>由于ES6以前的属性诞生年底久远，我们使用也比较普遍，遂不进行说明，ES6之后的语言风格跟ES5以前的差异比较大，所以单独拎出来做个记录。</p>
<h1 id="ES6-ES2015"><a href="#ES6-ES2015" class="headerlink" title="ES6(ES2015)"></a>ES6(ES2015)</h1><p>ES6是一次重大的革新，比起过去的版本，改动比较大，本文仅对常用的API以及语法糖进行讲解。</p>
<h2 id="Let-和-Const"><a href="#Let-和-Const" class="headerlink" title="Let 和 Const"></a>Let 和 Const</h2><p>在ES6以前，JS只有var一种声明方式，但是在ES6之后，就多了let跟const这两种方式。用var定义的变量没有块级作用域的概念，而let跟const则会有，因为这三个关键字创建是不一样的。</p>
<p>区别如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">  <span class="keyword">const</span> c = <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// 10</span></span><br><span class="line">b <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line">c <span class="comment">// c is not defined</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">40</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="number">50</span></span><br><span class="line">d = <span class="number">60</span></span><br><span class="line">d <span class="comment">// 60</span></span><br><span class="line">e = <span class="number">70</span> <span class="comment">// VM231:1 Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">var</th>
<th style="text-align:center">let</th>
<th style="text-align:center">const</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">变量提升</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">全局变量</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">重复声明</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">重新赋值</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">暂时死区</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">块作用域</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">只声明不初始化</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h2 id="类（Class）"><a href="#类（Class）" class="headerlink" title="类（Class）"></a>类（Class）</h2><p>在ES6之前，如果我们要生成一个实例对象，传统的方法就是写一个构造函数，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.information = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在ES6之后，我们只需要写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  information() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="箭头函数（Arrow-function）"><a href="#箭头函数（Arrow-function）" class="headerlink" title="箭头函数（Arrow function）"></a>箭头函数（Arrow function）</h2><p>箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或 new.target。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。</p>
<p>在ES6以前，我们写函数一般是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> newList = list.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * item</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是在ES6里，我们可以：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> newList = list.map(<span class="function"><span class="params">item</span> =&gt;</span> item * item)</span><br></pre></td></tr></table></figure>
<h2 id="函数参数默认值（Function-parameter-defaults）"><a href="#函数参数默认值（Function-parameter-defaults）" class="headerlink" title="函数参数默认值（Function parameter defaults）"></a>函数参数默认值（Function parameter defaults）</h2><p>在ES6之前，如果我们写函数需要定义初始值的时候，需要这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">config</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = data || <span class="string">'data is empty'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样看起来也没有问题，但是如果参数的布尔值为falsy时就会出问题，例如我们这样调用config：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">config(<span class="number">0</span>)</span><br><span class="line">config(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>那么结果就永远是后面的值</p>
<p>如果我们用函数参数默认值就没有这个问题，写法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> config = <span class="function">(<span class="params">data = <span class="string">'data is empty'</span></span>) =&gt;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串（Template-string）"><a href="#模板字符串（Template-string）" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h2><p>在ES6之前，如果我们要拼接字符串，则需要像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'kris'</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">var</span> info = <span class="string">'My name is '</span> + <span class="keyword">this</span>.name + <span class="string">', I am '</span> + <span class="keyword">this</span>.age</span><br></pre></td></tr></table></figure>
<p>但是在ES6之后，我们只需要写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'kris'</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">24</span></span><br><span class="line"><span class="keyword">const</span> info = <span class="string">`My name is <span class="subst">$&#123;name&#125;</span>, I am <span class="subst">$&#123;age&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<h2 id="解构赋值（Destructuring-assignment）"><a href="#解构赋值（Destructuring-assignment）" class="headerlink" title="解构赋值（Destructuring assignment）"></a>解构赋值（Destructuring assignment）</h2><p>我们通过解构赋值, 可以将属性/值从对象/数组中取出,赋值给其他变量。</p>
<p>比如我们需要交换两个变量的值，在ES6之前我们可能需要：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br></pre></td></tr></table></figure>
<p>但是在ES6里，我们有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">20</span></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure>
<h2 id="模块化（Module）"><a href="#模块化（Module）" class="headerlink" title="模块化（Module）"></a>模块化（Module）</h2><p>在ES6之前，JS并没有模块化的概念，有的也只是社区定制的类似CommonJS和AMD之类的规则。例如基于CommonJS的NodeJS：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line">exports.area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line">exports.circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">const</span> circle = <span class="built_in">require</span>(<span class="string">'./circle.js'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是 <span class="subst">$&#123;circle.area(<span class="number">4</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<p>在ES6之后我们则可以写成以下形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> area = <span class="function">(<span class="params">r</span>) =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> circumference = <span class="function">(<span class="params">r</span>) =&gt;</span> <span class="number">2</span> * PI * r</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> &#123; area &#125; = <span class="string">'./circle.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是: <span class="subst">$&#123;area(<span class="number">4</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>
<h2 id="扩展操作符（Spread-operator）"><a href="#扩展操作符（Spread-operator）" class="headerlink" title="扩展操作符（Spread operator）"></a>扩展操作符（Spread operator）</h2><p>扩展操作符可以在函数调用/数组构造时, 将数组表达式或者string在语法层面展开；还可以在构造字面量对象时, 将对象表达式按key-value的方式展开。</p>
<p>比如在ES5的时候，我们要对一个数组的元素进行相加，在不使用reduce或者reduceRight的场合，我们需要：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">var</span> total = sum.apply(<span class="literal">null</span>, list)</span><br></pre></td></tr></table></figure>
<p>但是如果我们使用扩展操作符，只需要如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z</span><br><span class="line"><span class="keyword">const</span> list = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">const</span> total = sum(...list)</span><br></pre></td></tr></table></figure>
<p>非常的简单，但是要注意的是扩展操作符只能用于可迭代对象</p>
<p>如果是下面的情况，是会报错的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> array = [...obj] <span class="comment">// TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>
<h2 id="对象属性简写（Object-attribute-shorthand）"><a href="#对象属性简写（Object-attribute-shorthand）" class="headerlink" title="对象属性简写（Object attribute shorthand）"></a>对象属性简写（Object attribute shorthand）</h2><p>在ES6之前，如果我们要将某个变量赋值为同样名称的对象元素，则需要：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = <span class="string">'Miaow'</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="string">'Woof'</span></span><br><span class="line"><span class="keyword">var</span> bird = <span class="string">'Peet peet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someObject = &#123;</span><br><span class="line">  cat: cat,</span><br><span class="line">  dog: dog,</span><br><span class="line">  bird: bird</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在ES6里我们就方便很多：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="string">'Miaow'</span></span><br><span class="line"><span class="keyword">let</span> dog = <span class="string">'Woof'</span></span><br><span class="line"><span class="keyword">let</span> bird = <span class="string">'Peet peet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someObject = &#123;</span><br><span class="line">  cat,</span><br><span class="line">  dog,</span><br><span class="line">  bird</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(someObject)</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//  cat: "Miaow",</span></span><br><span class="line"><span class="comment">//  dog: "Woof",</span></span><br><span class="line"><span class="comment">//  bird: "Peet peet"</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<p>非常方便</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是ES6提供的一种异步解决方案，比回调函数更加清晰明了。</p>
<p>Promise 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p>
<p>1.等待中（pending）<br>2.完成了 （resolved）<br>3.拒绝了（rejected）</p>
<p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">  <span class="comment">// 无效</span></span><br><span class="line">  reject(<span class="string">'reject'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Promise'</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'finifsh'</span>)</span><br><span class="line"><span class="comment">// new Promise -&gt; finifsh</span></span><br></pre></td></tr></table></figure>
<p>Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 包装成 Promise.resolve(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>当然了，Promise 也很好地解决了回调地狱的问题，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">  ajax(url1, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url2, () =&gt; &#123;</span><br><span class="line">      <span class="comment">// 处理逻辑</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>可以改写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url1)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">      <span class="keyword">return</span> ajax(url2)</span><br><span class="line">  &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p>for…of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> array1) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "c"</span></span><br></pre></td></tr></table></figure>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>symbol 是一种基本数据类型，Symbol()函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的symbol注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”new Symbol()”。</p>
<p>每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> symbol2 = <span class="built_in">Symbol</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> symbol3 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol1); <span class="comment">// "symbol"</span></span><br><span class="line"><span class="built_in">console</span>.log(symbol3.toString()); <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代器（Iterator）-生成器（Generator）"><a href="#迭代器（Iterator）-生成器（Generator）" class="headerlink" title="迭代器（Iterator）/ 生成器（Generator）"></a>迭代器（Iterator）/ 生成器（Generator）</h2><p>迭代器（Iterator）是一种迭代的机制，为各种不同的数据结构提供统一的访问机制。任何数据结构只要内部有 Iterator 接口，就可以完成依次迭代操作。</p>
<p>一旦创建，迭代器对象可以通过重复调用next()显式地迭代，从而获取该对象每一级的值，直到迭代完，返回{ value: undefined, done: true }</p>
<p>虽然自定义的迭代器是一个有用的工具，但由于需要显式地维护其内部状态，因此需要谨慎地创建。生成器函数提供了一个强大的选择：它允许你定义一个包含自有迭代算法的函数， 同时它可以自动维护自己的状态。生成器函数使用 function*[2]语法编写。最初调用时，生成器函数不执行任何代码，而是返回一种称为Generator的迭代器。通过调用生成器的下一个方法消耗值时，Generator函数将执行，直到遇到yield关键字。</p>
<p>可以根据需要多次调用该函数，并且每次都返回一个新的Generator，但每个Generator只能迭代一次。</p>
<p>所以我们可以有以下例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeRangeIterator</span>(<span class="params">start = <span class="number">0</span>, end = Infinity, step = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; end; i += step) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = makeRangeIterator(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">a.next() <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 7, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: 9, done: false&#125;</span></span><br><span class="line">a.next() <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Set-WeakSet"><a href="#Set-WeakSet" class="headerlink" title="Set/WeakSet"></a>Set/WeakSet</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>
<p>所以我们可以通过Set实现数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">32</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(numbers)])</span><br><span class="line"><span class="comment">// [2, 3, 4, 5, 6, 7, 32]</span></span><br></pre></td></tr></table></figure>
<p>WeakSet 结构与 Set 类似，但区别有以下两点：</p>
<ul>
<li>WeakSet 对象中只能存放对象引用, 不能存放值, 而 Set 对象都可以。</li>
<li>WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素。</li>
</ul>
<p>所以代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">ws.add(<span class="built_in">window</span>)</span><br><span class="line">ws.add(obj)</span><br><span class="line"></span><br><span class="line">ws.has(<span class="built_in">window</span>) <span class="comment">// true</span></span><br><span class="line">ws.has(foo)    <span class="comment">// false, 对象 foo 并没有被添加进 ws 中</span></span><br><span class="line"></span><br><span class="line">ws.delete(<span class="built_in">window</span>) <span class="comment">// 从集合中删除 window 对象</span></span><br><span class="line">ws.has(<span class="built_in">window</span>)    <span class="comment">// false, window 对象已经被删除了</span></span><br><span class="line"></span><br><span class="line">ws.clear() <span class="comment">// 清空整个 WeakSet 对象</span></span><br></pre></td></tr></table></figure>
<h2 id="Map-WeakMap"><a href="#Map-WeakMap" class="headerlink" title="Map/WeakMap"></a>Map/WeakMap</h2><p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</p>
<p>例子如下，我们甚至可以使用NaN来作为键值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">myMap.set(<span class="literal">NaN</span>, <span class="string">"not a number"</span>);</span><br><span class="line"></span><br><span class="line">myMap.get(<span class="literal">NaN</span>); <span class="comment">// "not a number"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> otherNaN = <span class="built_in">Number</span>(<span class="string">"foo"</span>);</span><br><span class="line">myMap.get(otherNaN); <span class="comment">// "not a number"</span></span><br></pre></td></tr></table></figure>
<p>WeakMap 对象是一组键/值对的集合，其中的键是弱引用的。其键必须是对象，而值可以是任意的。</p>
<p>跟Map的区别与Set跟WeakSet的区别相似，具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> wm1 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">var</span> wm2 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">var</span> wm3 = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="built_in">window</span></span><br><span class="line"></span><br><span class="line">wm1.set(o1, <span class="number">37</span>);</span><br><span class="line">wm1.set(o2, <span class="string">"azerty"</span>);</span><br><span class="line">wm2.set(o1, o2); <span class="comment">// value可以是任意值,包括一个对象</span></span><br><span class="line">wm2.set(o3, <span class="literal">undefined</span>);</span><br><span class="line">wm2.set(wm1, wm2); <span class="comment">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class="line">wm1.get(o2); <span class="comment">// "azerty"</span></span><br><span class="line">wm2.get(o2); <span class="comment">// undefined,wm2中没有o2这个键</span></span><br><span class="line">wm2.get(o3); <span class="comment">// undefined,值就是undefined</span></span><br><span class="line"></span><br><span class="line">wm1.has(o2); <span class="comment">// true</span></span><br><span class="line">wm2.has(o2); <span class="comment">// false</span></span><br><span class="line">wm2.has(o3); <span class="comment">// true (即使值是undefined)</span></span><br><span class="line"></span><br><span class="line">wm3.set(o1, <span class="number">37</span>);</span><br><span class="line">wm3.get(o1); <span class="comment">// 37</span></span><br><span class="line">wm3.clear();</span><br><span class="line">wm3.get(o1); <span class="comment">// undefined,wm3已被清空</span></span><br><span class="line">wm1.has(o1);   <span class="comment">// true</span></span><br><span class="line">wm1.delete(o1);</span><br><span class="line">wm1.has(o1);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="Proxy-Reflect"><a href="#Proxy-Reflect" class="headerlink" title="Proxy/Reflect"></a>Proxy/Reflect</h2><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。</p>
<p>Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 Proxy 的方法相同。Reflect不是一个函数对象，因此它是不可构造的。</p>
<p>Proxy跟Reflect是非常完美的配合，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> observe = <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value, proxy) &#123;</span><br><span class="line">      callback(key, value);</span><br><span class="line">      target[key] = value;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FooBar = &#123; <span class="attr">open</span>: <span class="literal">false</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> FooBarObserver = observe(FooBar, (property, value) =&gt; &#123;</span><br><span class="line">  property === <span class="string">'open'</span> &amp;&amp; value ? <span class="built_in">console</span>.log(<span class="string">'FooBar is open!!!'</span>) : <span class="built_in">console</span>.log(<span class="string">'keep waiting'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(FooBarObserver.open) <span class="comment">// false</span></span><br><span class="line">FooBarObserver.open = <span class="literal">true</span> <span class="comment">// FooBar is open!!!</span></span><br></pre></td></tr></table></figure>
<p>当然也不是什么都可以被代理的，如果对象带有configurable: false 跟writable: false 属性，则代理失效。</p>
<h2 id="Regex对象的扩展"><a href="#Regex对象的扩展" class="headerlink" title="Regex对象的扩展"></a>Regex对象的扩展</h2><h3 id="正则新增符号"><a href="#正则新增符号" class="headerlink" title="正则新增符号"></a>正则新增符号</h3><ul>
<li>i 修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i 修饰符</span></span><br><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>y修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// y修饰符</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<ul>
<li>String.prototype.flags</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查看RegExp构造函数的修饰符</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>)</span><br><span class="line">regex.flags <span class="comment">// 'i'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>unicode模式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span></span><br><span class="line">/^.$/.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>u转义</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// u转义</span></span><br><span class="line">/\,/ <span class="comment">// /\,/</span></span><br><span class="line">/\,/u <span class="comment">// 报错 没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>引用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RE_TWICE = <span class="regexp">/^(?&lt;word&gt;[a-z]+)!\1$/</span>;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串方法的实现改为调用RegExp方法"><a href="#字符串方法的实现改为调用RegExp方法" class="headerlink" title="字符串方法的实现改为调用RegExp方法"></a>字符串方法的实现改为调用RegExp方法</h3><ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
<h3 id="正则新增属性"><a href="#正则新增属性" class="headerlink" title="正则新增属性"></a>正则新增属性</h3><ul>
<li>RegExp.prototype.sticky 表示是否有y修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/hello\d/y.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>RegExp.prototype.flags获取修饰符</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/abc/ig.flags <span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure>
<h2 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h2><ul>
<li><p>二进制表示法 : 0b或0B开头表示二进制(0bXX或0BXX)</p>
</li>
<li><p>二进制表示法 : 0b或0B开头表示二进制(0bXX或0BXX)</p>
</li>
<li><p>八进制表示法 : 0o或0O开头表示二进制(0oXX或0OXX)</p>
</li>
<li><p>Number.EPSILON : 数值最小精度</p>
</li>
<li><p>Number.MIN_SAFE_INTEGER : 最小安全数值(-2^53)</p>
</li>
<li><p>Number.MAX_SAFE_INTEGER : 最大安全数值(2^53)</p>
</li>
<li><p>Number.parseInt() : 返回转换值的整数部分</p>
</li>
<li><p>Number.parseFloat() : 返回转换值的浮点数部分</p>
</li>
<li><p>Number.isFinite() : 是否为有限数值</p>
</li>
<li><p>Number.isNaN() : 是否为NaN</p>
</li>
<li><p>Number.isInteger() : 是否为整数</p>
</li>
<li><p>Number.isSafeInteger() : 是否在数值安全范围内</p>
</li>
<li><p>Math.trunc() : 返回数值整数部分</p>
</li>
<li><p>Math.sign() : 返回数值类型(正数1、负数-1、零0)</p>
</li>
<li><p>Math.cbrt() : 返回数值立方根</p>
</li>
<li><p>Math.clz32() : 返回数值的32位无符号整数形式</p>
</li>
<li><p>Math.imul() : 返回两个数值相乘</p>
</li>
<li><p>Math.fround() : 返回数值的32位单精度浮点数形式</p>
</li>
<li><p>Math.hypot() : 返回所有数值平方和的平方根</p>
</li>
<li><p>Math.expm1() : 返回e^n - 1</p>
</li>
<li><p>Math.log1p() : 返回1 + n的自然对数(Math.log(1 + n))</p>
</li>
<li><p>Math.log10() : 返回以10为底的n的对数</p>
</li>
<li><p>Math.log2() : 返回以2为底的n的对数</p>
</li>
<li><p>Math.sinh() : 返回n的双曲正弦</p>
</li>
<li><p>Math.cosh() : 返回n的双曲余弦</p>
</li>
<li><p>Math.tanh() : 返回n的双曲正切</p>
</li>
<li><p>Math.asinh() : 返回n的反双曲正弦</p>
</li>
<li><p>Math.acosh() : 返回n的反双曲余弦</p>
</li>
<li><p>Math.atanh() : 返回n的反双曲正切</p>
</li>
</ul>
<h2 id="Array对象的扩展"><a href="#Array对象的扩展" class="headerlink" title="Array对象的扩展"></a>Array对象的扩展</h2><ul>
<li>Array.prototype.from：转换具有Iterator接口的数据结构为真正数组，返回新数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(<span class="string">'foo'</span>)) <span class="comment">// ["f", "o", "o"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], x =&gt; x + x)) <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.of()：转换一组值为真正数组，返回新数组。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">7</span>)       <span class="comment">// [7]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">7</span>)          <span class="comment">// [empty, empty, empty, empty, empty, empty]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)    <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.copyWithin()：把指定位置的成员复制到其他位置，返回原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// ["d", "b", "c", "d", "e"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.copyWithin(<span class="number">1</span>, <span class="number">3</span>)) <span class="comment">// ["d", "d", "e", "d", "e"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.find()：返回第一个符合条件的成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = array1.find(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.findIndex()：返回第一个符合条件的成员索引值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isLargeNumber = <span class="function">(<span class="params">element</span>) =&gt;</span> element &gt; <span class="number">13</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.findIndex(isLargeNumber)) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.fill()：根据指定值填充整个数组，返回原数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>)) <span class="comment">// [1, 2, 0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">5</span>, <span class="number">1</span>)) <span class="comment">// [1, 5, 5, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.fill(<span class="number">6</span>)) <span class="comment">// [6, 6, 6, 6]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.keys()：返回以索引值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.keys()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.values()：返回以属性值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.values()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Array.prototype.entries()：返回以索引值和属性值为遍历器的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">const</span> iterator = array1.entries()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">// [0, "a"]</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">// [1, "b"]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>数组空位：ES6明确将数组空位转为undefined或者empty</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>]) <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]] <span class="comment">// [ "a", undefined, "b" ]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">//  [empty × 3]</span></span><br><span class="line">[,<span class="string">'a'</span>] <span class="comment">// [empty, "a"]</span></span><br></pre></td></tr></table></figure>
<h1 id="ES7-ES2016"><a href="#ES7-ES2016" class="headerlink" title="ES7(ES2016)"></a>ES7(ES2016)</h1><h2 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h2><p>includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(array1.includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pets = [<span class="string">'cat'</span>, <span class="string">'dog'</span>, <span class="string">'bat'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'cat'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">'at'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="幂运算符"><a href="#幂运算符" class="headerlink" title="幂运算符**"></a>幂运算符**</h2><p>幂运算符**，具有与Math.pow()一样的功能，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>**<span class="number">10</span>) <span class="comment">// 1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)) <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符串（Template-string）-1"><a href="#模板字符串（Template-string）-1" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h2><p>自ES7起，带标签的模版字面量遵守以下转义序列的规则：</p>
<ul>
<li>Unicode字符以”\u”开头，例如\u00A9</li>
<li>Unicode码位用”\u{}”表示，例如\u{2F804}</li>
<li>十六进制以”\x”开头，例如\xA9</li>
<li>八进制以””和数字开头，例如\251</li>
</ul>
<p>这表示类似下面这种带标签的模版是有问题的，因为对于每一个ECMAScript语法，解析器都会去查找有效的转义序列，但是只能得到这是一个形式错误的语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">latex<span class="string">`\unicode`</span></span><br><span class="line"><span class="comment">// 在较老的ECMAScript版本中报错（ES2016及更早）</span></span><br><span class="line"><span class="comment">// SyntaxError: malformed Unicode character escape sequence</span></span><br></pre></td></tr></table></figure>
<h1 id="ES8-ES2017"><a href="#ES8-ES2017" class="headerlink" title="ES8(ES2017)"></a>ES8(ES2017)</h1><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>虽然Promise可以解决回调地狱的问题，但是链式调用太多，则会变成另一种形式的回调地狱 —— 面条地狱，所以在ES8里则出现了Promise的语法糖async/await，专门解决这个问题。</p>
<p>我们先看一下下面的Promise代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> response.blob())</span><br><span class="line">  .then(<span class="function"><span class="params">myBlob</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob)</span><br><span class="line">    <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">    image.src = objectURL</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'There has been a problem with your fetch operation: '</span> + e.message)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>然后再看看async/await版的，这样看起来是不是更清晰了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">  <span class="keyword">let</span> myBlob = <span class="keyword">await</span> response.blob()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(myBlob)</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">  image.src = objectURL</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch()</span><br></pre></td></tr></table></figure>
<p>当然，如果你喜欢，你甚至可以两者混用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFetch</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(<span class="string">'coffee.jpg'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> response.blob()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFetch().then(<span class="function">(<span class="params">blob</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> objectURL = URL.createObjectURL(blob)</span><br><span class="line">  <span class="keyword">let</span> image = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">  image.src = objectURL</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(image)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h2><p>Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for…in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="string">'somestring'</span>,</span><br><span class="line">  b: <span class="number">42</span>,</span><br><span class="line">  c: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(object1)) <span class="comment">// ["somestring", 42, false]</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h2><p>Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for…in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="string">'somestring'</span>,</span><br><span class="line">  b: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object1)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "a: somestring"</span></span><br><span class="line"><span class="comment">// "b: 42"</span></span><br></pre></td></tr></table></figure>
<h2 id="padStart"><a href="#padStart" class="headerlink" title="padStart()"></a>padStart()</h2><p>padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'5'</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.padStart(<span class="number">2</span>, <span class="string">'0'</span>)) <span class="comment">// "05"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fullNumber = <span class="string">'2034399002125581'</span></span><br><span class="line"><span class="keyword">const</span> last4Digits = fullNumber.slice(<span class="number">-4</span>)</span><br><span class="line"><span class="keyword">const</span> maskedNumber = last4Digits.padStart(fullNumber.length, <span class="string">'*'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(maskedNumber) <span class="comment">// "************5581"</span></span><br></pre></td></tr></table></figure>
<h2 id="padEnd"><a href="#padEnd" class="headerlink" title="padEnd()"></a>padEnd()</h2><p>padEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str1 = <span class="string">'Breaded Mushrooms'</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.padEnd(<span class="number">25</span>, <span class="string">'.'</span>)) <span class="comment">// "Breaded Mushrooms........"</span></span><br><span class="line"><span class="keyword">const</span> str2 = <span class="string">'200'</span></span><br><span class="line"><span class="built_in">console</span>.log(str2.padEnd(<span class="number">5</span>)) <span class="comment">// "200  "</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数结尾逗号（Function-parameter-lists-and-calls-trailing-commas）"><a href="#函数参数结尾逗号（Function-parameter-lists-and-calls-trailing-commas）" class="headerlink" title="函数参数结尾逗号（Function parameter lists and calls trailing commas）"></a>函数参数结尾逗号（Function parameter lists and calls trailing commas）</h2><p>在ES5里就添加了对象的尾逗号，不过并不支持函数参数，但是在ES8之后，便开始支持这一特性，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">p,</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">(p) =&gt; &#123;&#125;</span><br><span class="line">(p,) =&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  one(a,) &#123;&#125;,</span><br><span class="line">  two(a, b,) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line">f(p)</span><br><span class="line">f(p,)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">10</span>, <span class="number">20</span>,)</span><br></pre></td></tr></table></figure>
<p>但是以下的方式是不合法的：</p>
<p>仅仅包含逗号的函数参数定义或者函数调用会抛出 SyntaxError。而且，当使用剩余参数的时候，并不支持尾后逗号，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">,</span>) </span>&#123;&#125; <span class="comment">// SyntaxError: missing formal parameter</span></span><br><span class="line">(,) =&gt; &#123;&#125;       <span class="comment">// SyntaxError: expected expression, got ','</span></span><br><span class="line">f(,)             <span class="comment">// SyntaxError: expected expression, got ','</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">...p,</span>) </span>&#123;&#125; <span class="comment">// SyntaxError: parameter after rest parameter</span></span><br><span class="line">(...p,) =&gt; &#123;&#125;        <span class="comment">// SyntaxError: expected closing parenthesis, got ','</span></span><br></pre></td></tr></table></figure>
<p>在解构里也可以使用，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带有尾后逗号的数组解构</span></span><br><span class="line">[a, b,] = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有尾后逗号的对象解构</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  p: <span class="number">42</span>,</span><br><span class="line">  q: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123;p, q,&#125; = o</span><br></pre></td></tr></table></figure>
<p>同样地，在使用剩余参数时，会抛出 SyntaxError，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, ...b,] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// SyntaxError: rest element may not have a trailing comma</span></span><br></pre></td></tr></table></figure>
<h2 id="ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）"><a href="#ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）" class="headerlink" title="ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）"></a>ShareArrayBuffer（因安全问题，暂时在Chrome跟FireFox中被禁用）</h2><p>SharedArrayBuffer 对象用来表示一个通用的，固定长度的原始二进制数据缓冲区，类似于 ArrayBuffer 对象，它们都可以用来在共享内存（shared memory）上创建视图。与 ArrayBuffer 不同的是，SharedArrayBuffer 不能被分离。</p>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sab = <span class="keyword">new</span> SharedArrayBuffer(<span class="number">1024</span>) <span class="comment">// 必须实例化</span></span><br><span class="line">worker.postMessage(sab)</span><br></pre></td></tr></table></figure>
<h2 id="Atomics对象"><a href="#Atomics对象" class="headerlink" title="Atomics对象"></a>Atomics对象</h2><p>Atomics对象 提供了一组静态方法用来对 SharedArrayBuffer[3] 对象进行原子操作。</p>
<p>方法如下：</p>
<ul>
<li><p>Atomics.add() ：将指定位置上的数组元素与给定的值相加，并返回相加前该元素的值。</p>
</li>
<li><p>Atomics.and()：将指定位置上的数组元素与给定的值相与，并返回与操作前该元素的值。</p>
</li>
<li><p>Atomics.compareExchange()：如果数组中指定的元素与给定的值相等，则将其更新为新的值，并返回该元素原先的值。</p>
</li>
<li><p>Atomics.exchange()：将数组中指定的元素更新为给定的值，并返回该元素更新前的值。</p>
</li>
<li><p>Atomics.load()：返回数组中指定元素的值。</p>
</li>
<li><p>Atomics.or()：将指定位置上的数组元素与给定的值相或，并返回或操作前该元素的值。</p>
</li>
<li><p>Atomics.store()：将数组中指定的元素设置为给定的值，并返回该值。</p>
</li>
<li><p>Atomics.sub()：将指定位置上的数组元素与给定的值相减，并返回相减前该元素的值。</p>
</li>
<li><p>Atomics.xor()：将指定位置上的数组元素与给定的值相异或，并返回异或操作前该元素的值。</p>
</li>
<li><p>Atomics.wait()：检测数组中某个指定位置上的值是否仍然是给定值，是则保持挂起直到被唤醒或超时。返回值为 “ok”、”not-equal” 或 “time-out”。调用时，如果当前线程不允许阻塞，则会抛出异常（大多数浏览器都不允许在主线程中调用 wait()）。</p>
</li>
<li><p>Atomics.wake()：唤醒等待队列中正在数组指定位置的元素上等待的线程。返回值为成功唤醒的线程数量。</p>
</li>
<li><p>Atomics.isLockFree(size)：可以用来检测当前系统是否支持硬件级的原子操作。对于指定大小的数组，如果当前系统支持硬件级的原子操作，则返回 true；否则就意味着对于该数组，Atomics 对象中的各原子操作都只能用锁来实现。此函数面向的是技术专家。</p>
</li>
</ul>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>Object.getOwnPropertyDescriptors() 方法用来获取一个对象的所有自身属性的描述符。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  property1: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptors1 = <span class="built_in">Object</span>.getOwnPropertyDescriptors(object1)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors1.property1.writable) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptors1.property1.value) <span class="comment">// 42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浅拷贝一个对象</span></span><br><span class="line"><span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">superclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">superclass.prototype = &#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subclass</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">subclass.prototype = <span class="built_in">Object</span>.create(superclass.prototype, <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">  <span class="comment">// 在这里定义方法和属性</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<h1 id="ES9-ES2018"><a href="#ES9-ES2018" class="headerlink" title="ES9(ES2018)"></a>ES9(ES2018)</h1><h2 id="for-await…of"><a href="#for-await…of" class="headerlink" title="for await…of"></a>for await…of</h2><p>for await…of 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 String，Array，Array-like 对象（比如arguments 或者NodeList)，TypedArray，Map， Set和自定义的异步或者同步可迭代对象。其会调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<p>配合迭代异步生成器，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (num <span class="keyword">of</span> asyncGenerator()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符串（Template-string）-2"><a href="#模板字符串（Template-string）-2" class="headerlink" title="模板字符串（Template string）"></a>模板字符串（Template string）</h2><p>ES9开始，模板字符串允许嵌套支持常见转义序列，移除对ECMAScript在带标签的模版字符串中转义序列的语法限制。</p>
<p>不过，非法转义序列在”cooked”当中仍然会体现出来。它们将以undefined元素的形式存在于”cooked”之中，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123; <span class="string">"cooked"</span>: str[<span class="number">0</span>], <span class="string">"raw"</span>: str.raw[<span class="number">0</span>] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">latex<span class="string">`\unicode`</span> <span class="comment">// &#123; cooked: undefined, raw: "\\unicode" &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式反向-lookbehind-断言"><a href="#正则表达式反向-lookbehind-断言" class="headerlink" title="正则表达式反向(lookbehind)断言"></a>正则表达式反向(lookbehind)断言</h2><p>首先我们得先知道什么是断言(Assertion)。</p>
<p>断言(Assertion)是一个对当前匹配位置之前或之后的字符的测试， 它不会实际消耗任何字符，所以断言也被称为“非消耗性匹配”或“非获取匹配”。</p>
<p>正则表达式的断言一共有 4 种形式：</p>
<ul>
<li>(?=pattern) 零宽正向肯定断言(zero-width positive lookahead assertion)</li>
<li>(?!pattern) 零宽正向否定断言(zero-width negative lookahead assertion)</li>
<li>(?&lt;=pattern) 零宽反向肯定断言(zero-width positive lookbehind assertion)</li>
<li>(?&lt;!pattern) 零宽反向否定断言(zero-width negative lookbehind assertion)</li>
</ul>
<p>在ES9之前，JavaScript 正则表达式，只支持正向断言。正向断言的意思是：当前位置后面的字符串应该满足断言，但是并不捕获。例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'fishHeadfishTail'</span>.match(<span class="regexp">/fish(?=Head)/g</span>) <span class="comment">// ["fish"]</span></span><br></pre></td></tr></table></figure>
<p>反向断言和正向断言的行为一样，只是方向相反。例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'abc123'</span>.match(<span class="regexp">/(?&lt;=(\d+)(\d+))$/</span>) <span class="comment">//  ["", "1", "23", index: 6, input: "abc123", groups: undefined]</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式-Unicode-转义"><a href="#正则表达式-Unicode-转义" class="headerlink" title="正则表达式 Unicode 转义"></a>正则表达式 Unicode 转义</h2><p>正则表达式中的Unicode转义符允许根据Unicode字符属性匹配Unicode字符。它允许区分字符类型，例如大写和小写字母，数学符号和标点符号。</p>
<p>部分例子代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有空格</span></span><br><span class="line">\p&#123;White_Space&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有字母，等同于 Unicode 版的 \w</span></span><br><span class="line">[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W</span></span><br><span class="line">[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 Emoji</span></span><br><span class="line">/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配所有的箭头字符</span></span><br><span class="line"><span class="keyword">const</span> regexArrows = <span class="regexp">/^\p&#123;Block=Arrows&#125;+$/u</span>;</span><br><span class="line">regexArrows.test(<span class="string">'←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>具体的属性列表可查看：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes</a></p>
<h2 id="正则表达式-s-dotAll-模式"><a href="#正则表达式-s-dotAll-模式" class="headerlink" title="正则表达式 s/dotAll 模式"></a>正则表达式 s/dotAll 模式</h2><p>在以往的版本里，JS的正则的.只能匹配emoji跟行终结符以外的所有文本，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/./</span>;</span><br><span class="line"></span><br><span class="line">regex.test(<span class="string">'\n'</span>);       <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\r'</span>);       <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;2028&#125;'</span>); <span class="comment">// false</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;2029&#125;'</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">regex.test(<span class="string">'\v'</span>);       <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'\f'</span>);       <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'\u&#123;0085&#125;'</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>);     <span class="comment">// false</span></span><br><span class="line">/foo[^]bar/.test(<span class="string">'foo\nbar'</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>);     <span class="comment">// false</span></span><br><span class="line">/foo[\s]bar/.test(<span class="string">'foo\nbar'</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>但是在ES9之后，JS正则增加了一个新的标志 s 用来表示 dotAll，这可以匹配任意字符。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s;  <span class="comment">//  等价于 const re = new RegExp('foo.bar', 's');</span></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>);    <span class="comment">// true</span></span><br><span class="line">re.dotAll;      <span class="comment">// true</span></span><br><span class="line">re.flags;       <span class="comment">// "s"</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式命名捕获组"><a href="#正则表达式命名捕获组" class="headerlink" title="正则表达式命名捕获组"></a>正则表达式命名捕获组</h2><p>在以往的版本里，JS的正则分组是无法命名的，所以容易混淆。例如下面获取年月日的例子，很容易让人搞不清哪个是月份，哪个是年份:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> matched = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>.exec(<span class="string">'2019-01-01'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">0</span>]);    <span class="comment">// 2019-01-01</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">1</span>]);    <span class="comment">// 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">2</span>]);    <span class="comment">// 01</span></span><br><span class="line"><span class="built_in">console</span>.log(matched[<span class="number">3</span>]);    <span class="comment">// 01</span></span><br></pre></td></tr></table></figure>
<p>ES9引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> month = matchObj.groups.month; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> day = matchObj.groups.day; <span class="comment">// 31</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RE_OPT_A = <span class="regexp">/^(?&lt;as&gt;a+)?$/</span>;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.as <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'as'</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="对象扩展操作符"><a href="#对象扩展操作符" class="headerlink" title="对象扩展操作符"></a>对象扩展操作符</h2><p>ES6中添加了数组的扩展操作符，让我们在操作数组时更加简便，美中不足的是并不支持对象扩展操作符，但是在ES9开始，这一功能也得到了支持，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">x</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123; <span class="attr">foo</span>: <span class="string">'baz'</span>, <span class="attr">y</span>: <span class="number">13</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> clonedObj = &#123; ...obj1 &#125;;</span><br><span class="line"><span class="comment">// 克隆后的对象: &#123; foo: "bar", x: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergedObj = &#123; ...obj1, ...obj2 &#125;;</span><br><span class="line"><span class="comment">// 合并后的对象: &#123; foo: "baz", x: 42, y: 13 &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面便是一个简便的浅拷贝。这里有一点小提示，就是Object.assign() 函数会触发 setters，而展开语法则不会。所以不能替换也不能模拟Object.assign() 。</p>
<p>如果存在相同的属性名，只有最后一个会生效。</p>
<h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><p>finally()方法会返回一个Promise，当promise的状态变更，不管是变成rejected或者fulfilled，最终都会执行finally()的回调。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(url)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'结束'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="ES10-ES2019"><a href="#ES10-ES2019" class="headerlink" title="ES10(ES2019)"></a>ES10(ES2019)</h1><h2 id="Array-prototype-flat-flatMap"><a href="#Array-prototype-flat-flatMap" class="headerlink" title="Array.prototype.flat() / flatMap()"></a>Array.prototype.flat() / flatMap()</h2><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p>
<p>flatMap()与 map() 方法和深度为1的 flat() 几乎相同.，不过它会首先使用映射函数映射每个元素，然后将结果压缩成一个新数组，这样效率会更高。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">arr1.map(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line"></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x * <span class="number">2</span>]) <span class="comment">// [2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度为1</span></span><br><span class="line">arr1.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]]) <span class="comment">// [[2], [4], [6], [8]]</span></span><br><span class="line">flatMap()可以代替reduce() 与 concat()，例子如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>]) <span class="comment">// [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">acc, x</span>) =&gt;</span> acc.concat([x, x * <span class="number">2</span>]), []) <span class="comment">// [1, 2, 2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>
<p>但这是非常低效的，在每次迭代中，它创建一个必须被垃圾收集的新临时数组，并且它将元素从当前的累加器数组复制到一个新的数组中，而不是将新的元素添加到现有的数组中。</p>
<h2 id="String-prototype-trimStart-trimLeft-trimEnd-trimRight"><a href="#String-prototype-trimStart-trimLeft-trimEnd-trimRight" class="headerlink" title="String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight()"></a>String.prototype.trimStart() / trimLeft() / trimEnd() / trimRight()</h2><p>在ES5中，我们可以通过trim()来去掉字符首尾的空格，但是却无法只去掉单边的，但是在ES10之后，我们可以实现这个功能。</p>
<p>如果我们要去掉开头的空格，可以使用trimStart()或者它的别名trimLeft()，</p>
<p>同样的，如果我们要去掉结尾的空格，我们可以使用trimEnd()或者它的别名trimRight()。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Str = <span class="string">'   Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str) <span class="comment">// '   Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimStart()) <span class="comment">// 'Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimLeft()) <span class="comment">// 'Hello world!  '</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimEnd()) <span class="comment">// '   Hello world!'</span></span><br><span class="line"><span class="built_in">console</span>.log(Str.trimRight()) <span class="comment">// '   Hello world!'</span></span><br></pre></td></tr></table></figure>
<p>不过这里有一点要注意的是，trimStart()跟trimEnd()才是标准方法，trimLeft()跟trimRight()只是别名。</p>
<p>在某些引擎里（例如Chrome），有以下的等式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.trimLeft.name === <span class="string">"trimStart"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.prototype.trimRight.name === <span class="string">"trimEnd"</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h2><p>Object.fromEntries() 方法把键值对列表转换为一个对象，它是Object.entries()的反函数。</p>
<p>例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">  [<span class="string">'baz'</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// Object &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Symbol-prototype-description"><a href="#Symbol-prototype-description" class="headerlink" title="Symbol.prototype.description"></a>Symbol.prototype.description</h2><p>description 是一个只读属性，它会返回Symbol对象的可选描述的字符串。与 Symbol.prototype.toString() 不同的是它不会包含Symbol()的字符串。例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">'desc'</span>).toString();   <span class="comment">// "Symbol(desc)"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">'desc'</span>).description;  <span class="comment">// "desc"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">''</span>).description;      <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">Symbol</span>().description;        <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名 symbols</span></span><br><span class="line"><span class="built_in">Symbol</span>.iterator.toString();  <span class="comment">// "Symbol(Symbol.iterator)"</span></span><br><span class="line"><span class="built_in">Symbol</span>.iterator.description; <span class="comment">// "Symbol.iterator"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局 symbols</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>).toString();  <span class="comment">// "Symbol(foo)"</span></span><br><span class="line"><span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>).description; <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<h2 id="String-prototype-matchAll"><a href="#String-prototype-matchAll" class="headerlink" title="String.prototype.matchAll"></a>String.prototype.matchAll</h2><p>matchAll() 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。并且返回一个不可重启的迭代器。例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/t(e)(st(\d?))/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'test1test2'</span></span><br><span class="line"></span><br><span class="line">str.match(regexp) <span class="comment">// ['test1', 'test2']</span></span><br><span class="line">str.matchAll(regexp) <span class="comment">// RegExpStringIterator &#123;&#125;</span></span><br><span class="line">[...str.matchAll(regexp)] <span class="comment">// [['test1', 'e', 'st1', '1', index: 0, input: 'test1test2', length: 4], ['test2', 'e', 'st2', '2', index: 5, input: 'test1test2', length: 4]]</span></span><br></pre></td></tr></table></figure>
<h2 id="Function-prototype-toString-返回注释与空格"><a href="#Function-prototype-toString-返回注释与空格" class="headerlink" title="Function.prototype.toString() 返回注释与空格"></a>Function.prototype.toString() 返回注释与空格</h2><p>在以往的版本中，Function.prototype.toString()得到的字符串是去掉空白符号的，但是从ES10开始会保留这些空格，如果是原生函数则返回你控制台看到的效果，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum.toString())</span><br><span class="line"><span class="comment">// "function sum(a, b) &#123;</span></span><br><span class="line"><span class="comment">//    return a + b;</span></span><br><span class="line"><span class="comment">//  &#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs.toString()) <span class="comment">// "function abs() &#123; [native code] &#125;"</span></span><br></pre></td></tr></table></figure>
<h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h2><p>在以往的版本中，try-catch里catch后面必须带异常参数，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES10之前</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// tryCode</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line"><span class="comment">// catchCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是在ES10之后，这个参数却不是必须的，如果用不到，我们可以不用传，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Foobar'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'Bar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>BigInt 是一种内置对象，它提供了一种方法来表示大于 253 - 1 的整数。这原本是 Javascript中可以用 Number 表示的最大数字。BigInt 可以表示任意大的整数。</p>
<p>可以用在一个整数字面量后面加 n 的方式定义一个 BigInt ，如：10n，或者调用函数BigInt()。</p>
<p>在以往的版本中，我们有以下的弊端：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 大于2的53次方的整数，无法保持精度</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">53</span> === (<span class="number">2</span> ** <span class="number">53</span> + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 超过2的1024次方的数值，无法表示</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">1024</span> <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>但是在ES10引入BigInt之后，这个问题便得到了解决。</p>
<p>以下操作符可以和 BigInt 一起使用： +、*、-、**、% 。除 &gt;&gt;&gt; （无符号右移）之外的位操作也可以支持。因为 BigInt 都是有符号的， &gt;&gt;&gt; （无符号右移）不能用于 BigInt。BigInt 不支持单目 (+) 运算符。</p>
<p>/ 操作符对于整数的运算也没问题。可是因为这些变量是 BigInt 而不是 BigDecimal ，该操作符结果会向零取整，也就是说不会返回小数部分。</p>
<p>BigInt 和 Number不是严格相等的，但是宽松相等的。</p>
<p>所以在BigInt出来以后，JS的原始类型便增加到了7个，如下：</p>
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (ES6)</li>
<li>BigInt (ES10)</li>
</ul>
<h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p>globalThis属性包含类似于全局对象 this值。所以在全局环境下，我们有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">globalThis === <span class="keyword">this</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h2><p>静态的import 语句用于导入由另一个模块导出的绑定。无论是否声明了 严格模式，导入的模块都运行在严格模式下。在浏览器中，import 语句只能在声明了 type=”module” 的 script 的标签中使用。</p>
<p>但是在ES10之后，我们有动态 import()，它不需要依赖 type=”module” 的script标签。</p>
<p>所以我们有以下例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="built_in">document</span>.querySelector(<span class="string">"main"</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> <span class="built_in">document</span>.querySelectorAll(<span class="string">"nav &gt; a"</span>)) &#123;</span><br><span class="line">  link.addEventListener(<span class="string">"click"</span>, e =&gt; &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'/modules/my-module.js'</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">module</span>.loadPageInto(main);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            main.textContent = err.message;</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="私有元素与方法"><a href="#私有元素与方法" class="headerlink" title="私有元素与方法"></a>私有元素与方法</h2><p>在ES10之前，如果我们要实现一个简单的计数器组件，我们可能会这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// web component 写法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> x() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.xValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> x(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.xValue = value</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame(<span class="keyword">this</span>.render.bind(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clicked() &#123;</span><br><span class="line">    <span class="keyword">this</span>.x++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.onclick = <span class="keyword">this</span>.clicked.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.xValue = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    <span class="keyword">this</span>.render()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">this</span>.textContent = <span class="keyword">this</span>.x.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'num-counter'</span>, Counter)</span><br></pre></td></tr></table></figure>
<p>但是在ES10之后我们可以使用私有变量进行组件封装，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">  #xValue = 0</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> #x() &#123;</span><br><span class="line">    return #xValue</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> #x(value) &#123;</span><br><span class="line">    this.#xValue = value</span><br><span class="line">    window.requestAnimationFrame(this.#render.bind(this))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #clicked() &#123;</span><br><span class="line">    this.#x++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    this.onclick = this.#clicked.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    this.#render()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  #render() &#123;</span><br><span class="line">    this.textContent = this.#x.toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.customElements.define(<span class="string">'num-counter'</span>, Counter)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS样式常用属性及书写顺序规范</title>
    <url>/2018/04/11/css-style/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是我创建的第一篇博客，整理一下前端开发三大工具之一——CSS的常用属性及书写顺序规范</p>
<h1 id="快速记忆"><a href="#快速记忆" class="headerlink" title="快速记忆"></a>快速记忆</h1><h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>状定形边字背其，上右下左顺时针。</p>
<a id="more"></a>
<ul>
<li>状（状态）</li>
<li>定（定位）</li>
<li>形（形状）</li>
<li>边（边框）</li>
<li>字（字体）</li>
<li>背（背景)</li>
<li>其（其他）</li>
</ul>
<p>属性越前则优先级越高。</p>
<h1 id="规范书写顺序原因"><a href="#规范书写顺序原因" class="headerlink" title="规范书写顺序原因"></a>规范书写顺序原因</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>减少浏览器reflow（回流），提升浏览器渲染dom的性能。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>浏览器的渲染流程为——</p>
<ol>
<li>解析html构建dom树，解析css构建css树：将html解析成树形的数据结构，将css解析成树形的数据结构；</li>
<li>构建render树：DOM树和CSS树合并之后形成的render树；</li>
<li>布局render树：有了render树，浏览器已经知道那些网页中有哪些节点，各个节点的css定义和以及它们的从属关系，从而计算出每个节点在屏幕中的位置；</li>
<li>绘制render树：按照计算出来的规则，通过显卡把内容画在屏幕上。</li>
</ol>
<p>css样式解析到显示至浏览器屏幕上就发生在②③④步骤，可见浏览器并不是一获取到css样式就立马开始解析而是根据css样式的书写顺序将之按照dom树的结构分布render样式，完成第②步，然后开始遍历每个树结点的css样式进行解析，此时的css样式的遍历顺序完全是按照之前的书写顺序。在解析过程中，一旦浏览器发现某个元素的定位变化影响布局，则需要倒回去重新渲染正如按照这样的书写书序：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">height</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">red</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br></pre></td></tr></table></figure>
<p>当浏览器解析到position的时候突然发现该元素是绝对定位元素需要脱离文档流，而之前却是按照普通元素进行解析的，所以不得不重新渲染，解除该元素在文档中所占位置，然而由于该元素的占位发生变化，其他元素也可能会受到它回流的影响而重新排位。最终导致③步骤花费的时间太久而影响到④步骤的显示，影响了用户体验。</p>
<p>所以规范的的css书写顺序对于文档渲染来说一定是事半功倍的！</p>
<h1 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h1><h2 id="状态类"><a href="#状态类" class="headerlink" title="状态类"></a>状态类</h2><ul>
<li>display: block | none | inline | compact | marker | inline-table | list-item | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-grou</li>
<li>visibility: inherit | visible | collapse | hidden  </li>
<li>float: none | left | right  </li>
<li>clear: none | left | right | both</li>
<li>overflow: visible | auto | hidden | scroll</li>
</ul>
<h2 id="定位类"><a href="#定位类" class="headerlink" title="定位类"></a>定位类</h2><ul>
<li>position: static | absolute | fixed | relative  </li>
<li>top：auto | length  </li>
<li>right: auto | length  </li>
<li>bottom: auto | length</li>
<li>left: auto | length  </li>
<li>z-index: auto | number</li>
</ul>
<h2 id="形状类"><a href="#形状类" class="headerlink" title="形状类"></a>形状类</h2><h3 id="宽"><a href="#宽" class="headerlink" title="宽"></a>宽</h3><ul>
<li>width: visible | auto | hidden | scroll</li>
<li>min-width: visible | auto | hidden | scroll</li>
<li>max-width: visible | auto | hidden | scroll</li>
</ul>
<h3 id="高"><a href="#高" class="headerlink" title="高"></a>高</h3><ul>
<li>height: auto | length</li>
<li>min-height: auto | length</li>
<li>max-height: auto | length</li>
</ul>
<h2 id="边框类"><a href="#边框类" class="headerlink" title="边框类"></a>边框类</h2><h3 id="maigin"><a href="#maigin" class="headerlink" title="maigin"></a>maigin</h3><ul>
<li>margin: auto | length</li>
<li>margin-top: auto | length</li>
<li>margin-right: auto | length</li>
<li>margin-bottom: auto | length</li>
<li>margin-left: auto | length</li>
</ul>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><ul>
<li>padding: auto | length</li>
<li>padding-top: auto | length</li>
<li>padding-right: auto | length</li>
<li>padding-bottom: auto | length</li>
<li>padding-left: auto | length</li>
</ul>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><h4 id="四边"><a href="#四边" class="headerlink" title="四边"></a>四边</h4><ul>
<li>border: border-width || border-style || border-color</li>
<li>border-top: border-width || border-style || border-color</li>
<li>border-right: border-width || border-style || border-color</li>
<li>border-bottom: border-width || border-style || border-color</li>
<li>border-left: border-width || border-style || border-color</li>
</ul>
<h4 id="边宽"><a href="#边宽" class="headerlink" title="边宽"></a>边宽</h4><ul>
<li>border-width: none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset</li>
<li>border-top-width: medium | thin | thick | length</li>
<li>border-right-width: medium | thin | thick | length</li>
<li>border-bottom-width: medium | thin | thick | length</li>
<li>border-left-width: medium | thin | thick | length</li>
</ul>
<h4 id="边样式"><a href="#边样式" class="headerlink" title="边样式"></a>边样式</h4><ul>
<li>border-style: none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset</li>
<li>border-top-style: border-width || border-style || border-color</li>
<li>border-right-style: border-width || border-style || border-color</li>
<li>border-bottom-style: border-width || border-style || border-color</li>
<li>border-left-style: border-width || border-style || border-color</li>
</ul>
<h4 id="边颜色"><a href="#边颜色" class="headerlink" title="边颜色"></a>边颜色</h4><ul>
<li>border-color: color</li>
<li>border-top-color: color</li>
<li>border-right-color: color</li>
<li>border-bottom-color: color</li>
<li>border-left-color: color</li>
</ul>
<h4 id="边圆角"><a href="#边圆角" class="headerlink" title="边圆角"></a>边圆角</h4><ul>
<li>border-radius: length</li>
</ul>
<h4 id="外边线"><a href="#外边线" class="headerlink" title="外边线"></a>外边线</h4><ul>
<li>outline: outline-color || outline-style || outline-width</li>
<li>list-style: list-style-image || list-style-position || list-style-type</li>
</ul>
<h4 id="其他边"><a href="#其他边" class="headerlink" title="其他边"></a>其他边</h4><ul>
<li>table-layout: auto | fixed</li>
<li>caption-side: top | right | bottom | left</li>
<li>border-collapse: separate | collapse</li>
<li>border-spacing: length</li>
<li>empty-cells: show | hide</li>
</ul>
<h2 id="字体类"><a href="#字体类" class="headerlink" title="字体类"></a>字体类</h2><ul>
<li>font: caption | icon | menu | message-box | small-caption | status-bar</li>
<li>font-family: ncursive | fantasy | monospace | serif | sans-serif</li>
<li>font-size: xx-small | x-small | small | medium | large | x-large | xx-large | larger | smaller | length</li>
<li>line-height: normal | length</li>
<li>font-weight: normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900  </li>
<li>text-align: left | right | center | justify</li>
<li>text-indent: length</li>
<li>text-transform: none | capitalize | uppercase | lowercase</li>
<li>text-decoration: none || underline || blink || overline || line-through</li>
<li>letter-spacing: normal | length</li>
<li>word-spacing: normal | length</li>
<li>white-space: normal | pre | nowrap</li>
<li>vertical-align: auto | baseline | sub | super | top | text-top | middle | bottom | text-bottom | length</li>
<li>color: color</li>
</ul>
<h2 id="背景类"><a href="#背景类" class="headerlink" title="背景类"></a>背景类</h2><ul>
<li>background: background-color || background-image || background-repeat || background-attachment || background-position</li>
<li>background-color: transparent | color</li>
<li>background-image: none | url ( url )</li>
<li>background-repeat: repeat | no-repeat | repeat-x | repeat-y</li>
<li>background-position: length || length || position</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>opacity：0-1</li>
<li>cursor: auto | all-scroll | col-resize| crosshair | default | hand | move | help | no-drop | not-allowed | pointer | progress | row-resize | text | vertical-text | wait | *-resize | url ( url )</li>
<li>content: attr(alt) | counter(name) | counter(name , list-style-type) | counters(name , string) | counters(name , string , list-style-type) | no-close-quote | no-open-quote | close-quote | open-quote | string | url(url)</li>
<li>quotes: none | string</li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用hexo搭建一个属于自己的博客网站</title>
    <url>/2018/04/21/build-hexo-blog/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为作者准备往前端方向发展，便想搭建一个属于自己的博客网站，用来发布一些文章以及交流学习。发现利用hexo来搭建个人博客挺方便的，于是便自己试着搭建了一个。特写下此文，一防忘记，二供大家参考。</p>
<a id="more"></a>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li>安装Git</li>
<li>安装NodeJs</li>
<li>安装hexo</li>
<li>生成SSH并添加到github</li>
<li>部署项目</li>
<li>上传到github</li>
<li>绑定个人域名</li>
<li>修改及配置主题</li>
<li>添加RSS</li>
<li>添加评论</li>
<li>写博客文章</li>
<li>站点管理文件</li>
</ol>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul>
<li>Git:<a href="https://gitforwindows.org/" target="_blank" rel="noopener">下载地址</a></li>
<li>参考文章:<a href="https://www.w3cschool.cn/git/git-install-setup.html" target="_blank" rel="noopener">《W3Cschool上Git教程之Git安装配置》</a></li>
</ul>
<h2 id="安装NodeJs"><a href="#安装NodeJs" class="headerlink" title="安装NodeJs"></a>安装NodeJs</h2><p>Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧！</p>
<p>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧！</p>
<ul>
<li>NodeJs<a href="https://nodejs.org/en/" target="_blank" rel="noopener">下载地址</a>(说明：LTS为长期支持版，Current为当前最新版)</li>
<li>参考文章:<a href="https://www.w3cschool.cn/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">《W3Cschool上Node.js教程之Node.js安装配置》</a></li>
</ul>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。</p>
<p>安装hexo命令：（在新建的文件夹里右键Git Bash Here）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i -g hexo</span><br></pre></td></tr></table></figure>
<p>接着初始化命令：hexo init ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
<p>初始化完成之后打开所在的文件夹可以看到以下文件：</p>
<img src="/2018/04/21/build-hexo-blog/b1.png" title="生成的文件">
<p>解释一下：</p>
<ul>
<li>node_modules：是依赖包</li>
<li>public：存放的是生成的页面</li>
<li>scaffolds：命令生成文章等的模板</li>
<li>source：用命令创建的各种文章</li>
<li>themes：主题</li>
<li>_config.yml：整个博客的配置</li>
<li>db.json：source解析所得到的</li>
<li>package.json：项目所需模块项目的配置信息</li>
</ul>
<p>做好这些前置工作之后接下来的就是各种配置了。</p>
<h1 id="配置工作"><a href="#配置工作" class="headerlink" title="配置工作"></a>配置工作</h1><h2 id="生成SSH并添加到github"><a href="#生成SSH并添加到github" class="headerlink" title="生成SSH并添加到github"></a>生成SSH并添加到github</h2><p>没账号的先创建一个github账号，有账号的看下面。<a href="https://github.com">注册传送门</a></p>
<p>创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用，如下：</p>
<img src="/2018/04/21/build-hexo-blog/b2.jpg" title="创建仓库">
<img src="/2018/04/21/build-hexo-blog/b3.jpg" title="为仓库取名">
<p>回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config global user.name &quot;YourName&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config global user.email &quot;YourEail&quot;</span><br></pre></td></tr></table></figure>
<p>配置ssh，Git bash中输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com</span><br></pre></td></tr></table></figure>
<p>一路回车，就能在你的电脑中产生ssh，ssh文件默认在:C:User/Administrator/.ssh文件夹下，打开.ssh文件夹下的id_rsa.pub文件，将里面的内容复制；再打开github的setting：</p>
<img src="/2018/04/21/build-hexo-blog/b4.png" title="打开setting">
<p>将.ssh文件夹下的id_rsa.pub文件里一经复制好了的内容添加到ssh keys:</p>
<img src="/2018/04/21/build-hexo-blog/b5.png" title="创建key">
<p>添加一个 New SSH key ，title随便取，key就填刚刚复制好了的那一段。</p>
<p>在Git bash中验证是否添加成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>完成下一步你就成功了！</p>
<h2 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h2><p>用编辑器打开你的blog项目，修改_config.yml文件的一些配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: https://github.com/yourgithubname/yourgithubname.github.io.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>在Git bash中，依次输入以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>注：hexo 3.0把服务器独立成个别模块，需要单独安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i hexo-server</span><br></pre></td></tr></table></figure>
<p>打开浏览器输入：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
<p>你就可以看到你的项目在本地能够预览了。</p>
<h2 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h2><p>先安装一波，这样才能将你写好的文章部署到github服务器上并让别人浏览到,输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>再依次执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>注意deploy的过程中(即hexo d)可能要输入你的github上的username及passward</p>
<p>一切都ok之后，在浏览器中输入<a href="#">http://yourgithubname.github.io</a>就可以看到你的个人博客，飞起来！！！</p>
<h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><p>虽然，使用<a href="#">http://yourgithubname.github.io</a>也可以让别人看到你写的博客。</p>
<p>但是，写博客写博客，还是要有点装逼的嘛。搭配一个属于自己的域名显然会让自己的博客变得高大上起来。</p>
<p>可以去各大域名销售平台买自己喜欢的域名。（不想绑定的可以跳过这一个环节直接看下一节）</p>
<p>第一步购买域名：随便在哪个网站买一个就行；</p>
<p>第二步添加CNAME：在项目的source文件夹下新建一个名为CNAME的文件，在里面添加你购买的域名：</p>
<img src="/2018/04/21/build-hexo-blog/b6.png" title="配置域名">
<p>其中ip地址为你的github的地址，可在cmd中ping一下就能看到(ping yourname.github.io)：</p>
<img src="/2018/04/21/build-hexo-blog/b7.png" title="ping">
<p>接着再次部署（hexo d）一下，用你购买的域名打开，就可以看到你的博客了了了了了！！！</p>
<h2 id="修改及配置主题"><a href="#修改及配置主题" class="headerlink" title="修改及配置主题"></a>修改及配置主题</h2><p>hexo初始化之后默认的主题是landscape , 然后你可以去<a href="https://hexo.io/themes/" target="_blank" rel="noopener">这个地址</a>里面找到你想要的主题。在github中搜索你要的主题名称，里面都会有该主题的如何使用的介绍，按着来就好了。本人采用的是raytaylorism主题，集体配置方法，看<a href="https://github.com/DM2N/DM2N.github.io/blob/hexo/themes/raytaylorism/README.md">这里</a>。</p>
<h2 id="添加RSS"><a href="#添加RSS" class="headerlink" title="添加RSS"></a>添加RSS</h2><p>先安装rss相关插件，Git bash命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i hexo-generator-feed</span><br></pre></td></tr></table></figure>
<p>在你的项目的_config.yml配置文件下找到Extensions添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions  #插件和主题</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line"># RSS订阅</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br></pre></td></tr></table></figure>
<p>进入到你的主题的配置文件下，找到你的放rss的位置，添加/atom.xml即可。重新部署再打开就能看到效果了。</p>
<h2 id="添加评论"><a href="#添加评论" class="headerlink" title="添加评论"></a>添加评论</h2><p>评论功能为第三方评论系统，但，多说、网易云跟帖等都已关闭服务。来必力等也能用，所以，骚年，翻墙吧，具体做法，聪明的你肯定是知道百度的。</p>
<h2 id="写博客文章"><a href="#写博客文章" class="headerlink" title="写博客文章"></a>写博客文章</h2><p>新建文章，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &apos;文章名&apos;</span><br></pre></td></tr></table></figure>
<p>然后你就可以在source/_posts路径下看到你创建的文章，编辑完成之后按照前面说的方式部署，在浏览器刷新就能看到你的文章了。</p>
<p>博客文章采用markdown格式编写，至于markdown，骚年，学习吧！！！–&gt;<a href="https://www.appinn.com/markdown/index.html" target="_blank" rel="noopener">前往教室</a></p>
<h2 id="站点管理文件"><a href="#站点管理文件" class="headerlink" title="站点管理文件"></a>站点管理文件</h2><p>如果本地站点文件丢失了或换了电脑怎么办？为解决这个问题，我们利用了Github的多分支来管理站点文件：</p>
<ol>
<li>用master分支来管理发布的文件，即public文件夹下的文件；</li>
<li>用hexo分支来管理主站点文件，即除public下和.gitignore忽视的其他文件；</li>
<li>将hexo设为默认分支。</li>
</ol>
<p>为此，我们要：</p>
<h3 id="建立远程仓库"><a href="#建立远程仓库" class="headerlink" title="建立远程仓库"></a>建立远程仓库</h3><p>先将远程仓库关联到本地。进入站点文件夹，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:username/username.github.io.git #使用站点仓库地址关联</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<h3 id="创建hexo分支"><a href="#创建hexo分支" class="headerlink" title="创建hexo分支"></a>创建hexo分支</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b hexo  #创建并切换到hexo分支</span><br></pre></td></tr></table></figure>
<h3 id="将hexo设为默认分支"><a href="#将hexo设为默认分支" class="headerlink" title="将hexo设为默认分支"></a>将hexo设为默认分支</h3><p>在Github上的站点仓库上，点击Settings=&gt;Branches，将Default branch切换成hexo，然后点击Update即可。</p>
<img src="/2018/04/21/build-hexo-blog/b8.png" title="change-branch">
<h3 id="将主站点文件push到hexo分支"><a href="#将主站点文件push到hexo分支" class="headerlink" title="将主站点文件push到hexo分支"></a>将主站点文件push到hexo分支</h3><p>在hexo分支（使用git branch命令查看当前所在分支）下，输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;提交记录&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push -u origin hexo  #初次push要加-u，此后可省</span><br></pre></td></tr></table></figure>
<h3 id="本地站点恢复"><a href="#本地站点恢复" class="headerlink" title="本地站点恢复"></a>本地站点恢复</h3><ol>
<li>使用git clone命令克隆站点仓库（默认分支为hexo）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:username/username.github.io.git</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在本地新拷贝的username.github.io文件夹下依次执行命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>注意，此时不需要执行hexo init这条命令。</p>
<p>到此，便完成了对站点的一些简单管理。</p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>raytaylorism</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS垂直居中</title>
    <url>/2018/09/06/css-vertical-center/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因为在工作中前端开发布局这方面涉及到的css垂直居中问题比较多，便总结了一下。</p>
<a id="more"></a>
<h1 id="1、Line-height"><a href="#1、Line-height" class="headerlink" title="1、Line-height"></a>1、Line-height</h1><p>适用情景：单行文字垂直居中技巧</p>
<p>这个方式应该是最多人知道的了，常见于单行文字的应用，像是按钮这一类对象，或者是下拉框、导航此类元素最常见到的方式了。此方式的原理是在于将单行文字的行高设定后，文字会位于行高的垂直中间位置，利用此原理就能轻松达成垂直居中的需求了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">line-height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>CSS垂直居中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="2、Line-height-inline-block"><a href="#2、Line-height-inline-block" class="headerlink" title="2、Line-height + inline-block"></a>2、Line-height + inline-block</h1><p>适用情景：多对象的垂直居中技巧</p>
<p>既然可以使用第一种方式对行元素达成垂直居中的话，当然没有理由不能做到多行啊~但是你需要将多个元素或多行元素当成一个行元素来看待，所以我们必须要将这些数据多包一层，并将其设定为inline-block，并在该inline-block对象的外层对象使用inline-block来代替height的设置，如此便可以达到垂直居中的目的了，从使你的数据是包含了标题跟内容在内也可以正常的垂直居中了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    line-height: 200px;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box2</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    height: auto;</span><br><span class="line"><span class="css">    <span class="selector-tag">line-height</span><span class="selector-pseudo">:1</span>;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="3、-before-inline-block"><a href="#3、-before-inline-block" class="headerlink" title="3、:before + inline-block"></a>3、:before + inline-block</h1><p>适用情景：多对象的CSS垂直居中技巧</p>
<p>:before 伪类元素搭配 inline-block 属性的写法应该是很传统的垂直居中的技巧了，此方式的好处在于子元素居中可以不需要特别设定高度，我们将利用:before伪类元素设定为100%高的inline-block，再搭配上将需要居中的子元素同样设置成inline-block性质后，就能使用vertical-align:middle来达到垂直居中的目的了，此方式在以往其实是个非常棒的垂直居中解决方案，唯独需要特别处理掉inline-block元素之间的4-5px空间这个小缺陷，但也很实用了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">content</span><span class="selector-pseudo">:''</span>;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    height: 100%;</span><br><span class="line">    width: 0;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>3.:before + inline-block<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="4、absolute-margin-负值"><a href="#4、absolute-margin-负值" class="headerlink" title="4、absolute + margin 负值"></a>4、absolute + margin 负值</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>谁说绝对定位要少用？Amos认为没有少用多用的问题，重点在于你是否有妥善运用才是重点，绝对定位在这个例子中会设置top:50%来抓取空间高度的50%，接着在将居中元素的margin-top设定为负一半的高度，这样就能让元素居中了，此方法可是自古以来流传多年的居中方式呢？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box4</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    height: 70px;</span><br><span class="line">    position: absolute;</span><br><span class="line"><span class="css">    <span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span></span><br><span class="line">    left: 50%;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">    margin-top: -35px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>4.absolute + margin 負值<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="5、absolute-margin-auto"><a href="#5、absolute-margin-auto" class="headerlink" title="5、absolute + margin auto"></a>5、absolute + margin auto</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>又一个绝对定位的垂直居中的方案，这个方式比较特别一点，当元素设置为绝对定位后，假设它是抓不到整体可运用的空间范围，所以margin:auto会失效，但当你设置了top:0;bottom:0;时，绝对定位元素就抓到了可运用的空间了，这时你的margin:auto就生效了（神奇吧），如果你的绝对定位元素需要水平居中于父层，那你同样可以设定left:0;right:0;来让绝对定位元素取得空间可运用范围，再让marign-left与margin-right设定为auto即可居中。但此方式的缺点是你的定位元素必须有固定的宽高（百分比也算）才能正常居中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    height: 70px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>5.absolute + translate(-50%, -50%)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="6、absolute-translate"><a href="#6、absolute-translate" class="headerlink" title="6、absolute + translate"></a>6、absolute + translate</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>在一个绝对定位居中的方式，此方式应该算是最方便的了，因为此居中的定位元素不需要固定的宽高，我们利用绝对定位时的top 与right设置元素的上方跟左方各为50%，再利用translate(-50%,-50%)位移居中元素自身宽与高的50%就能达成居中的目的了。（css3好棒）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box5</span> <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    position: absolute;</span><br><span class="line"><span class="css">    <span class="selector-tag">top</span><span class="selector-pseudo">:50</span>%;</span></span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>6.absolute + margin: auto<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="7、Flex-align-items"><a href="#7、Flex-align-items" class="headerlink" title="7、Flex + align-items"></a>7、Flex + align-items</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>Flex！前端的毒品！后端的宝物！这东西自从面世之后就不断的考验网页开发者的良心，到底要不要抛弃float拥抱flex，我想这答案人人心中自由一把尺，但先碰Flex再碰Float可谓先甜后苦，这顺序到底要倒吃甘蔗还是正吃甘蔗是实在难说，自从有了Flex之后，小孩考试一百分，设计网页不跑版，客户网页都RWD，老板赚钱好开心，我也加薪（加班）好甘心，不由的说Flex真的是一个神物，我们只要设定父层display:flex以及设定次轴(cross axis)属性align-items:center 就好了（说那么多结果重点就一行字是哪招啦），这个方式的优点是此层不需要设定高度即可自动居中，且原始代码干净无比，真的是用一次就让你升天啦。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>7.Flex + align-items<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box7"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="8、Flex-before-flex-grow"><a href="#8、Flex-before-flex-grow" class="headerlink" title="8、Flex + :before + flex-grow"></a>8、Flex + :before + flex-grow</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>Flex有多种方式可以让你把数据居中，适用Flex-grow的延展特性来达成，这个例子中Amos适用了flex-direction:column直式排法，搭配:before伪元素适用flex-grow伸展值能够取得剩下所有空间的特性，把它设定成一半的剩余空间就能做到把内容数据准确的推到垂直中间位置，算是个传统技法的延伸方式。这样的话上面第七个方式不是比较快？</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span><span class="selector-pseudo">:before</span> &#123;</span></span><br><span class="line">    content: '';</span><br><span class="line"><span class="css">    <span class="selector-tag">flex-grow</span>: <span class="selector-class">.5</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>8.Flex + before + flex-grow<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="9、Flex-margin"><a href="#9、Flex-margin" class="headerlink" title="9、Flex + margin"></a>9、Flex + margin</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>继续用Flex来居中，由于Flex元素对空间解读的特殊性，我们只要在父层元素设定display:flex，接着在需要垂直居中的元素上设定margin:auto，即可自动居中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>9.Flex + margin<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box9"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="10、Flex-align-self"><a href="#10、Flex-align-self" class="headerlink" title="10、Flex + align-self"></a>10、Flex + align-self</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>align-self 应该大家都不陌生，基本上就是对flex次轴cross axis 的个别对齐方式只要对单一子层元素设定align-self:center就能达成垂直居中的目的了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    align-self: center</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>10.Flex + align-self<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box10"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="11、Flex-align-content"><a href="#11、Flex-align-content" class="headerlink" title="11、Flex + align-content"></a>11、Flex + align-content</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>在正常的状况下，align-content 仅能对次轴多行flex item做居中，但是当我今天子层元素不确定有多少个时，且有时可能会有单个的情况出现时，此技巧就能用到了（当然你也能有其他解法），既然是多行子元素才能用，那我们就为单个子组件多加两个兄弟吧，使用:before以及:after 来让子元素增加到多个，这样就能使用flex的align-content属性来居中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-content: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box11</span><span class="selector-pseudo">:before</span>,</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box11</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">    content: '';</span><br><span class="line">    display: block;</span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>11.Flex + align-content<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box11"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="12、Grid-template"><a href="#12、Grid-template" class="headerlink" title="12、Grid + template"></a>12、Grid + template</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>CSS Grid最令人惊讶的就是这个template的功能了，简直就是把块元素当画布在使用，我们仅需要把模板设置成三列，就能搞定垂直居中了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-rows: 1fr auto 1fr;</span><br><span class="line">    grid-template-columns: 1fr auto 1fr;</span><br><span class="line">    grid-template-areas: </span><br><span class="line">      '. . .'</span><br><span class="line">      '. amos .'</span><br><span class="line">      '. . .';</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    grid-area: amos;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>12.Grid + template<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box12"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="13、Grid-align-items"><a href="#13、Grid-align-items" class="headerlink" title="13、Grid + align-items"></a>13、Grid + align-items</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>align-items不仅是Flex可用，连CSS Grid也拥有此属性可使用，但在Flex中align-items是针对次轴cross axis作对齐，而在CSS Grid中则是针对Y轴做对齐，你可以把它想象成是表格中储存单元格的vertical-align属性看待，就可以很好理解了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: grid;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-items: center; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>13.Grid + align-items<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box13"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="14、Grid-align-content"><a href="#14、Grid-align-content" class="headerlink" title="14、Grid + align-content"></a>14、Grid + align-content</h1><p>适用情景：杜航文字的垂直居中技巧</p>
<p>CSS Grid的align-content跟Flex的align-content有点差异，CSS Grid对于空间的解释会跟Flex有一些些的落差，所以导致align-content在Flex中仅能针对多行元素起作用，但在Grid中就没这个问题，所以我们可以很开心的使用align-content来对子元素做垂直居中，丝毫不费力气</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: grid;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    align-content: center; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>14.Grid + align-content<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box14"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="15、Grid-align-self"><a href="#15、Grid-align-self" class="headerlink" title="15、Grid + align-self"></a>15、Grid + align-self</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>align-self 应该大家都不陌生，基本上就是对grid Y轴的个别对齐方式，只要对单一子层元素设置为align-self:center就能达成垂直居中的目的了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: grid;</span><br><span class="line">    justify-content: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    align-self: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>15.Grid + align-self<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box15"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="16、Grid-place-items"><a href="#16、Grid-place-items" class="headerlink" title="16、Grid + place-items"></a>16、Grid + place-items</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>place-items这属性不知道有多少人用过，此属性是align-items与justify-items的缩写，简单的说就是水平与垂直的对齐方式，想当然的，设定center就能居中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: grid;</span><br><span class="line">    height: 150px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    place-items: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>16.Grid + place-items<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box16"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="17、Grid-place-content"><a href="#17、Grid-place-content" class="headerlink" title="17、Grid + place-content"></a>17、Grid + place-content</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>place-content这属性有多少人用过，此属性是align-content与justify-content的缩写，简单的说就是水平与垂直的对齐方式，想当然的，设置center就能居中了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: grid;</span><br><span class="line">    height: 150px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    place-content: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>17.Grid + place-content<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box17"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="18、Grid-margin"><a href="#18、Grid-margin" class="headerlink" title="18、Grid + margin"></a>18、Grid + margin</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>继续用Grid来居中，由于Grid元素对空间解读的特殊性，我们只要在父层元素设定display:grid，接着在需要垂直居中的元素上设置margin:auto即可自动居中。怎么这描述似曾相识。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    display: grid;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:auto</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>18.Grid + margin<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box18"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="19、Display：table-cell"><a href="#19、Display：table-cell" class="headerlink" title="19、Display：table-cell"></a>19、Display：table-cell</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>这一招我想有点年纪的开发者应该都有看过，当然像我这么嫩的开发者当然是第一次看到啦，这一招的原理在于使用 CSS display属性将div设置成表格的单元格，这样就能利用支持存储单元格对齐的vertical-align属性来将信息垂直居中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    text-align: center;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>19.display: table-cell<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box19"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="20、calc"><a href="#20、calc" class="headerlink" title="20、calc"></a>20、calc</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>Calc是计算机英文单词calculator的缩写，这个由微软提出的css 方法，真的是网页开发者的一个福音。我们竟然可以在网页中直接做计算，这真是太猛了，从此我们再也不用在那边绞尽脑汁的数学计算了，或是想办法用js来动态计算，我们可以很轻松的利用calc()这个方法，来将百分比及时且动态的计算出实际要的是什么高度，真可谓是划时代的一个方法啊，但这个方法需要注意的是大量使用的话，网页性能会是比较差的，所以请谨慎使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    top:calc((100% - 70px) / 2);</span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:auto</span>;</span></span><br><span class="line">    height: 70px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>20.calc<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box20"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="21、Relative-translateY"><a href="#21、Relative-translateY" class="headerlink" title="21、Relative + translateY"></a>21、Relative + translateY</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>这个技巧是利用了top:50%的招式，让你的元素上方能产生固定百分比的距离，接着让要居中的元素本身使用tanslateY的百分比来达成垂直居中的需求，translate是一个很棒的属性，由于translate的百分比单位是利用元素自身的尺寸作为100%，这样让我们要利用元素自身宽高做事变得方便很多。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    position: relative;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translateY(-50%);</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>21.relative + translateY(-50%)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box21"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="22、padding"><a href="#22、padding" class="headerlink" title="22、padding"></a>22、padding</h1><p>适用情景：多行文字的垂直居中技巧</p>
<p>什么！这也算垂直居中技巧，连我奶奶都知道这方式吧</p>
<p>对的，这的确也算是一种垂直居中的方式，不可讳言的这方式真的是简单过头了，以至于有些开发者认为这种方式都不能算是一种垂直居中的技巧，但同样的你无法反驳的是，我的数据的确垂直居中啦，好啦，就当我硬凹吧，你说的对，好吧</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">    height: auto;</span><br><span class="line">    padding: 50px 0;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>22.padding<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box22"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    CSS垂直居中</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="23、Write-mode"><a href="#23、Write-mode" class="headerlink" title="23、Write-mode"></a>23、Write-mode</h1><p>适用情景：多行文字的垂直剧种技巧</p>
<p>这个方式应该是比较少见到的有人使用的了，这个想法是被老友Paul所激发的，write-mode这个css属性的功能基本上跟垂直居中是八竿子打不着，它的用途是改变文字书写的方向从横变竖，且支持度从很早期的IE5就有支持了，但当时Amos很少使用，一来是网页多是横书较多，另外当时除了IE浏览器意外，其他浏览器的支持度都不是很好，也就很少使用了。</p>
<p>使用write-mode将一整个文字容器变成直书，接着将此容器利用text-align:center来达到垂直居中的目的，白话一点的解说就是，你把原本横排的文字变成竖排，所以原本横排用到的水平对齐方式，就变成了控制直排的中间了，原理就是这么简单。但要特别注意的是浏览器对此语法的支持度来说，需要拆开写法才行，不然某些浏览器的语法不同，可能会让你的网页在某些浏览器上看起来无效，这会是最需要注意到的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  h2 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 250px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#f00</span>;</span></span><br><span class="line">    margin: auto;</span><br><span class="line"><span class="css">    <span class="selector-tag">writing-mode</span>: <span class="selector-tag">tb-lr</span>; <span class="comment">/* for ie11 */</span></span></span><br><span class="line">    writing-mode: vertical-lr;</span><br><span class="line">    text-align: center;</span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> <span class="selector-tag">auto</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">    width: 400px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>; <span class="comment">/* for ie &amp; edge */</span></span></span><br><span class="line">    width: 100%;</span><br><span class="line">    writing-mode: lr-tb;</span><br><span class="line">    margin: auto; </span><br><span class="line">    text-align: left;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> <span class="selector-class">.txt</span> &#123;</span></span><br><span class="line">    width: 80%;</span><br><span class="line">    margin: auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>23.writing-mode<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>立马来看Amos实际完成的</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box23"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"txt"</span>&gt;</span></span><br><span class="line">      CSS垂直居中</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>Vertical Center</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery 学习笔记</title>
    <url>/2018/04/19/jquery-study-note/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此为前端学习笔记之 jquery 篇。</p>
<a id="more"></a>
<p>jQuery大部分功能需要根据文档的DOM模型来工作，首先需要正确地解析到整个文档的DOM模型结构。使用jQuery需要在整个文档被浏览器完全加载后才开始进行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Hello World!"</span>);</span><br><span class="line">    $(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"Thanks for visiting!"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>$是在jQuery中使用的变量名，可以使用 jQuery.noConflict()避免冲突，它的返回值就是jQuery对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery.noConflict();</span><br><span class="line">$j = jQuery.noConflict();</span><br></pre></td></tr></table></figure>
<h2 id="jQuery对象与DOM对象之间的转换"><a href="#jQuery对象与DOM对象之间的转换" class="headerlink" title="jQuery对象与DOM对象之间的转换"></a>jQuery对象与DOM对象之间的转换</h2><p>使用 $()得到的是一个jQuery对象。它封装了很多 DOM 对象的操作，但是它和 DOM 对象之间是不同的。只有当 obj是一个DOM对象时才能使用 obj.innerHTML；相应地，如果是jQuery对象应该使用 obj.html() 。</p>
<ul>
<li><p>从 DOM 对象转到 jQuery 对象： $(obj)</p>
</li>
<li><p>从 jQuery 对象转到 DOM 对象： obj[0]</p>
</li>
</ul>
<p>比较正规地从 jQuery 对象到 DOM 的转换，是使用 jQuery 对象的 get() 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">"li"</span>).get();</span><br><span class="line">    $(<span class="string">"li"</span>).get(<span class="number">0</span>);</span><br><span class="line">    $(<span class="string">"li"</span>).get(<span class="number">-1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="jQuery选择器"><a href="#jQuery选择器" class="headerlink" title="jQuery选择器"></a>jQuery选择器</h1><h2 id="常规选择器"><a href="#常规选择器" class="headerlink" title="常规选择器"></a>常规选择器</h2><ul>
<li>$(“*”) 选择所有节点</li>
<li>$(“#id”) ID选择器，注意其中的一些特殊字符，如 .</li>
<li>$(“.class”) 类选择器</li>
<li>$(“tag”) 标签选择器</li>
<li>$(“子元素”)</li>
<li>$(“直接子元素”)</li>
<li>:focus 获取焦点元素</li>
<li>:first-child/:last-child 选择第一个/最后一个元素</li>
<li>:first/:last 截取第一个/最后一个符合条件的元素</li>
<li>(“pre+next”) 直接兄弟元素</li>
<li>(“pre~siblings”) 兄弟元素</li>
<li>:nth-child() 索引选择，索引从1开始</li>
<li>:nth-child(odd)</li>
<li>:nth-child(even)</li>
<li>:nth-child(4n)</li>
</ul>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><ul>
<li>[name~=”value”] 属性中包括某单词</li>
<li>[name=”value”] 属性完全等于指定值</li>
<li>[name!=”value”] 属性不等于指定值</li>
<li>[name] 包括有指定属性的元素</li>
</ul>
<h2 id="控件选择器"><a href="#控件选择器" class="headerlink" title="控件选择器"></a>控件选择器</h2><ul>
<li>:checked 选择所有被选中的元素</li>
<li>:selected 被选择的元素</li>
<li>:disabled/:enabled 选择被禁用/未禁用的元素</li>
<li>:hidden 隐藏元素，不仅是 [type=”hidden”]，还有 displa:none</li>
<li>:visible 可见控件， visibility:hidden和 opacity:0同样被认为是可见</li>
<li>:input:button:checkbox:file:image:password:radio:reset:submit:text 具体控件，图像控件是 [type=”image”]</li>
</ul>
<h2 id="其他选择器"><a href="#其他选择器" class="headerlink" title="其他选择器"></a>其他选择器</h2><ul>
<li>[name=”value”][name2=”value2”] 多个AND条件</li>
<li>(“selector1, selector2, selectorN”) 多个OR条件</li>
<li>:not() 否定选择</li>
<li>(‘:contains(“text”)’) 包含有指定内容的元素</li>
<li>:eq():lt():gt():even:odd 列表索引选择（不支持负数）</li>
<li>(‘:has(selector)’) 符合条件的再次过滤</li>
<li>:header 选择 h1,h2,h3…标题元素</li>
<li>:only-child 仅有一个子元素的元素</li>
<li>:empty 空元素，即无内容也无元素</li>
<li>:parent 非空元素</li>
</ul>
<h1 id="节点漫游"><a href="#节点漫游" class="headerlink" title="节点漫游"></a>节点漫游</h1><h2 id="调用链处理"><a href="#调用链处理" class="headerlink" title="调用链处理"></a>调用链处理</h2><ul>
<li>.add() 向已有的节点序列中添加新的对象</li>
<li>.andSelf() 在调用链中，随时加入原始序列</li>
<li>.eq() 指定索引选取节点，支持负数</li>
<li>.filter().is().not().find().first().last().has() 序列选择</li>
<li>.end() 节点回溯</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'ul.first'</span>).find(<span class="string">'.foo'</span>).css(<span class="string">'background-color'</span>, <span class="string">'red'</span>).end().find(<span class="string">'.bar'</span>).css(<span class="string">'background-color'</span>, <span class="string">'green'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><ul>
<li>.children() 所有的子节点，可加入过滤条件， .children(selector)</li>
</ul>
<h2 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h2><ul>
<li>.siblings().next().nextAll().nextUntil().prevAll().prevUntil().closet() 选择兄弟节点</li>
</ul>
<h2 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h2><ul>
<li>.parent().parents().parentUntil() 父节点选择</li>
</ul>
<h1 id="元素控制"><a href="#元素控制" class="headerlink" title="元素控制"></a>元素控制</h1><h2 id="attributes和-properties的区别"><a href="#attributes和-properties的区别" class="headerlink" title="attributes和 properties的区别"></a>attributes和 properties的区别</h2><p>attributes 是XML结构中的属性节点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onload</span> = <span class="string">"prettyPrint()"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>properties 是DOM对象，对象属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).get(<span class="number">0</span>).tagName;</span><br></pre></td></tr></table></figure>
<h2 id="类与属性控制"><a href="#类与属性控制" class="headerlink" title="类与属性控制"></a>类与属性控制</h2><ul>
<li>.addCLass().hasClass().removeClass() 添加一个类，判断是否有指定类，删除类</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).addClass(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'body'</span>).addClass(<span class="function"><span class="keyword">function</span> (<span class="params">index, current</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> current + <span class="string">'new'</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'body'</span>).removeClass(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'body'</span>).removeClass(<span class="function"><span class="keyword">function</span> (<span class="params">index, current</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> current + <span class="string">' '</span> + <span class="string">'other'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>.toggleClass() 类的开关式转换</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'img'</span>).toggleClass(); <span class="comment">//对所有类的开关</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'img'</span>).toggleClass(<span class="string">'test'</span>); <span class="comment">//对指定类的开关</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'img'</span>).toggleClass(isTrue); <span class="comment">//根据`isTrue`判断所有类的开关</span></span><br><span class="line"></span><br><span class="line">$(<span class="string">'img'</span>).toggleClass(<span class="string">'test'</span>, isTrue); <span class="comment">//根据`isTrue`判断指定类的开关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同 `$('img').toggleClass('test');` 只是类名由函数返回</span></span><br><span class="line">$(<span class="string">'img'</span>).toggleClass(<span class="function"><span class="keyword">function</span> (<span class="params">index, className, isTrue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `isTrue`作为函数的第三个参数传入</span></span><br><span class="line">$(<span class="string">'img'</span>).toggleClass(<span class="function"><span class="keyword">function</span> (<span class="params">index, className, isTrue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'name'</span></span><br><span class="line">&#125;, isTrue);</span><br></pre></td></tr></table></figure>
<ul>
<li>.attr() 获取或设置一个属性值</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $("#greatphoto").attr('alt'); //获取属性`</span></span><br><span class="line">$(<span class="string">"#greatphoto"</span>).attr(<span class="string">'alt'</span>, <span class="string">'Shenzhen Brush Seller'</span>); <span class="comment">//设置属性`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时设置多个属性</span></span><br><span class="line">$(<span class="string">'#greatphoto'</span>).attr(&#123;<span class="attr">alt</span>: <span class="string">'Shen Brush Seller'</span>,<span class="attr">title</span>: <span class="string">'photo by Kelly Clark'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置属性为函数返回值，函数的上下文为当前元素</span></span><br><span class="line">$(<span class="string">'#greatphoto'</span>).attr(<span class="string">'title'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val + <span class="string">' - photo by Kelly Clark'</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>.prop() 用法同 .attr()，只是对象变成了 properties</li>
<li>.removeAttr().removeProp() 删除属性</li>
<li>.val() 设置或获取元素的表单值，通常用于表单元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'input'</span>).val();</span><br><span class="line">$(<span class="string">'input'</span>).val(<span class="string">'other'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>.html() 设置或获取元素的节点 html</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).html();</span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="string">'&lt;div&gt;测试&lt;/div&gt;'</span>);</span><br><span class="line">$(<span class="string">'div'</span>).html(<span class="function"><span class="keyword">function</span> (<span class="params">index, old</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> old + <span class="string">'&lt;span&gt;另外的内容&lt;/span&gt;'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="样式控制"><a href="#样式控制" class="headerlink" title="样式控制"></a>样式控制</h2><ul>
<li>.css() 获取或设置指定的CSS样式</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).css(<span class="string">'background-color'</span>, <span class="string">'red'</span>);</span><br><span class="line">$(<span class="string">'body'</span>).css(<span class="string">'background-color'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value + <span class="string">'1'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'body'</span>).css(&#123;<span class="attr">color</span>: <span class="string">'green'</span>, <span class="string">'background-color'</span>: <span class="string">'red'</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>.width().height() 获取或设置元素的宽和高</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).width();</span><br><span class="line">$(<span class="string">'body'</span>).width(<span class="number">50</span>);</span><br><span class="line">$(<span class="string">'body'</span>).width(<span class="function"><span class="keyword">function</span> (<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value += <span class="number">10</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>.innerWidth().innerHeight().outerHeight().outerWidth() 元素的其他尺寸值</li>
<li>.scrollLefgt().scrollTop() 获取或设置滚动条的位置</li>
<li>.offset().position() 获取元素的坐标。 offset是相对于 document， position是相对于父级元素</li>
</ul>
<h2 id="结构控制"><a href="#结构控制" class="headerlink" title="结构控制"></a>结构控制</h2><h3 id="文本节点"><a href="#文本节点" class="headerlink" title="文本节点"></a>文本节点</h3><p>.html().text() 设置和获取节点的文本值。设置时 .text()会转义标签，获取时 .text()会移除所有标签。</p>
<h3 id="子节点-1"><a href="#子节点-1" class="headerlink" title="子节点"></a>子节点</h3><p>.append().prepend()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.inner'</span>).append(<span class="string">'&lt;p&gt;Test&lt;/p&gt;'</span>);</span><br></pre></td></tr></table></figure>
<p>参数可以有多种形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $newdiv1 = $(<span class="string">'&lt;div id="object1"/&gt;'</span>),</span><br><span class="line">    newdiv2 = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>),</span><br><span class="line">    existingdiv1 = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span><br><span class="line">$(<span class="string">'body'</span>).append($newdiv1, [newdiv2, existingdiv1]);</span><br></pre></td></tr></table></figure>
<h3 id="兄弟节点-1"><a href="#兄弟节点-1" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><p>.after().before()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.inner'</span>).after(<span class="string">'&lt;p&gt;Test&lt;/p&gt;'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="父节点-1"><a href="#父节点-1" class="headerlink" title="父节点"></a>父节点</h3><p>.wrap().wrap().wrapInner()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'.inner'</span>).wrap(<span class="string">'&lt;div class="new"&gt;&lt;/div&gt;'</span>);</span><br><span class="line">$(<span class="string">'.inner'</span>).wrapAll(<span class="string">'&lt;div class="new"&gt;&lt;/div&gt;'</span>);</span><br><span class="line">$(<span class="string">'.inner'</span>).wrapInner(<span class="string">'&lt;div class="new"&gt;&lt;/div&gt;'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="复制-删除-替换节点"><a href="#复制-删除-替换节点" class="headerlink" title="复制/删除/替换节点"></a>复制/删除/替换节点</h3><ul>
<li>.clone() 复制节点，可选参数表示是否处理已绑定的事件与数据</li>
<li>.clone(true) 处理当前节点的事件与数据</li>
<li>.clone(true,true) 处理当前节点及所有子节点的事件与数据</li>
<li>.detach() 暂时移除节点，之后可以再次恢复指定位置</li>
<li>.remove() 永久移除节点</li>
<li>.empty() 清除一个节点的所有内部内容</li>
<li>.unwrap() 移除节点的父节点</li>
</ul>
<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><ul>
<li>.map() 遍历所有成员</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">':checkbox'</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">&#125;).get().join(<span class="string">','</span>);</span><br><span class="line">$(<span class="string">':checkbox'</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">index, node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.id;</span><br><span class="line">&#125;).get().join(<span class="string">','</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>.slice() 序列切片，支持一个或两个参数，支持负数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'li'</span>).slice(<span class="number">2</span>).css(<span class="string">'background-color'</span>, <span class="string">'red'</span>);</span><br><span class="line">$(<span class="string">'li'</span>).slice(<span class="number">2</span>, <span class="number">4</span>).css(<span class="string">'background-color'</span>, <span class="string">'green'</span>);</span><br><span class="line">$(<span class="string">'li'</span>).slice(<span class="number">-2</span>, <span class="number">-1</span>).css(<span class="string">'background-color'</span>, <span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h2><ul>
<li>$.each()$.map() 遍历列表， $.map()可以用于对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.each([<span class="number">52</span>, <span class="number">97</span>], <span class="function"><span class="keyword">function</span> (<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((index + <span class="string">' : '</span> + value));</span><br><span class="line">&#125;);</span><br><span class="line">$.map([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">index, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n + <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$.map([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? n + <span class="number">1</span> : <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line">$.map([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [n, n + <span class="number">1</span>];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dimensions = &#123;<span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">15</span>, <span class="attr">length</span>: <span class="number">20</span>&#125;;</span><br><span class="line">$.map(dimensions, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dimensions = &#123;<span class="attr">width</span>: <span class="number">10</span>, <span class="attr">height</span>: <span class="number">15</span>, <span class="attr">length</span>: <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">$.map(dimensions, <span class="function"><span class="keyword">function</span> (<span class="params">value, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key;&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>$.extend() 合并对象，第一个参数表示是否进行递归深入</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">varobject = $.extend(&#123;&#125;, object1, object2);</span><br><span class="line"><span class="keyword">var</span> object = $.extend(<span class="literal">true</span>, &#123;&#125;, object1, object2);</span><br></pre></td></tr></table></figure>
<ul>
<li>$.merge() 合并列表</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.merge([<span class="number">0</span>, <span class="number">1</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br></pre></td></tr></table></figure>
<ul>
<li>.grep() 过滤列表，第三个参数表示是否为取反</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.grep([<span class="number">0</span>, <span class="number">1</span>, ], <span class="function"><span class="keyword">function</span> (<span class="params">array, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;);<span class="comment">//[1,2]</span></span><br><span class="line">$.grep([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], <span class="function"><span class="keyword">function</span> (<span class="params">array, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span>;</span><br><span class="line">&#125;, <span class="literal">true</span>);<span class="comment">//[0]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>$.inArray() 存在判断</li>
<li>$.inArray(value, array [, fromIndex])</li>
<li>$.isArray()$.isEmptyObject()$.isFunction()$.iSNumeric()$.isPainObject()$.isWindow $.isXMLDoc() 类型判断</li>
<li>$.noop() 空函数</li>
<li>$.now() 当前时间戳，值为 (newDate).getTime()</li>
<li>$.parseJson()$.parseXML() 把字符串解析为对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xml = <span class="string">"&lt;rss version='2.0'&gt;&lt;channel&gt;&lt;title&gt;RSS Title&lt;/title&gt;&lt;/channel&gt;&lt;/rss&gt;"</span>,</span><br><span class="line">    xmlDoc = $.parseXML(xml),</span><br><span class="line">    $xml = $(xmlDoc),</span><br><span class="line">    $title = $xml.find(<span class="string">"title"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>$.trim() 去头去尾 $.trim(str)</li>
<li>$.type() 判断参数的类型</li>
<li>$.unique() 遍历后去重。 $.unique(arraty)</li>
</ul>
<h1 id="上下文绑定"><a href="#上下文绑定" class="headerlink" title="上下文绑定"></a>上下文绑定</h1><ul>
<li>$.proxy() 为函数绑定上下文</li>
<li>$.proxy(function,context)</li>
<li>$.proxy(context,name)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    x: <span class="string">'123'</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span> (<span class="params">f</span>) </span>&#123;</span><br><span class="line">    f()</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.f();<span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">go(o.f);<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">go($.proxy(o.f, o));<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">$.proxy(o, <span class="string">'f'</span>)(); <span class="comment">//123</span></span><br></pre></td></tr></table></figure>
<p>当一个函数被传递之后，它就失去了原先的上下文。</p>
<h1 id="把数据存到节点中"><a href="#把数据存到节点中" class="headerlink" title="把数据存到节点中"></a><strong>把数据存到节点中</strong></h1><p>jQuery提供了一种机制，可以把节点作为数据存储的容器。</p>
<ul>
<li>$.data() 往节点中获取/设置数据</li>
<li>$.removeData() 删除数据</li>
</ul>
<p>在内部实现上，jQuery会在指定节点添加一个内部标识，以此为 key，把数据存在内部闭包的一个结构中。</p>
<p>事实上，jQuery的事件绑定机制也使用了这套数据接口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$.data($(<span class="string">'#data'</span>).get(<span class="number">0</span>), <span class="string">'test'</span>, <span class="string">'123'</span>);</span><br><span class="line">$(<span class="string">'#data'</span>).data(<span class="string">'test'</span>, <span class="string">'456'</span>);</span><br></pre></td></tr></table></figure>
<h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>在 jQuery1.7之后，推荐统一使用 on()来进行事件绑定。</p>
<ul>
<li>.on() 绑定事件 on()的基本使用方式是： .on(event,handler)</li>
<li>.off() 移除事件</li>
<li>.one() 绑定单次事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于 handler，它默认的上下文是触发事件的节点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用 $.proxy()可以随意控制上下文：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, $.proxy(<span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">    &#125;, &#123;<span class="attr">a</span>: <span class="number">123</span></span><br><span class="line">&#125;)); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>event参数还支持通过：</p>
<ul>
<li>以 .分割的子名字</li>
<li>以空格分割的多个事件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click.my'</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'123'</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#btn'</span>).off(<span class="string">'click.my'</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>多个事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click.my click.other'</span>,(<span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'123'</span>);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#btn'</span>).off(<span class="string">'click.my'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>on()的另一种调用形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(&#123;<span class="string">'click'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click'</span>);</span><br><span class="line">    &#125;,<span class="string">'mousemove'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'move'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>off()的使用方式与 on()完全类似：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, f);</span><br><span class="line">$(<span class="string">'#btn'</span>).off(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p>事件的触发有两种方式，一是使用预定的“事件函数”（ .click()， .focus()），二是使用 trigger()或 triggerHandler()。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">eventObj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'#btn'</span>).click();</span><br><span class="line">$(<span class="string">'#btn'</span>).trigger(<span class="string">'click'</span>);</span><br></pre></td></tr></table></figure>
<p>trigger()与 triggerHandler()不同之处在于前面是触发事件，而后者是执行绑定函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'focus'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'#btn'</span>).triggerHandler(<span class="string">'focus'</span>);</span><br></pre></td></tr></table></figure>
<p>trigger()和 triggerHandler()也用于触发自定义事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'my'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'#btn'</span>).triggerHandler(<span class="string">'my'</span>);</span><br></pre></td></tr></table></figure>
<p>trigger()和 triggerHandler()触发事件时，可以带上参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#btn'</span>).on(<span class="string">'my'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'#btn'</span>).trigger(<span class="string">'my'</span>, &#123;<span class="attr">a</span>: <span class="number">123</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>行为事件：</p>
<ul>
<li>.click() 单击</li>
<li>.dbclick() 双击</li>
<li>.blur() 失去焦点时</li>
<li>.change() 值变化时</li>
<li>.focus() 获取焦点时</li>
<li>.focusin() jQuery扩展的获取焦点</li>
<li>.focusout() jQuery扩展的失去焦点</li>
<li>.resize() 调整大小</li>
<li>.scroll() 滚动</li>
<li>.select() 被选择</li>
<li>.submit() 表单被提交</li>
</ul>
<p>键盘事件：</p>
<ul>
<li>.keydown() 按下键</li>
<li>.keyup() 放开键</li>
</ul>
<p>鼠标事件：</p>
<ul>
<li>.mousedown() 点下鼠标</li>
<li>.mouseup() 松开鼠标</li>
<li>.mouseover() 光标移入</li>
<li>.mouseout() 光标移出</li>
<li>.mousemove() 光标在其上移动</li>
<li>.mouseleave().mouseenter() 光标移出/移入</li>
</ul>
<p>页面事件：</p>
<ul>
<li>.ready() 准备就绪</li>
<li>.unload() 离开当前页时，针对 window对象</li>
<li>.error() 发生错误时</li>
<li>.load() 正在载入</li>
</ul>
<h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a><strong>事件对象</strong></h1><ul>
<li>event.currentTarget,event,target 事件绑定节点/事件的触发节点（冒泡行为）</li>
<li>event.delegateTarget 绑定事件的对象，通常就是 event.currentTarget</li>
<li>event.relatedTarget 相关的节点，主要用于一些转换式的事件。比如鼠标移入，表示它从哪个节点来的</li>
<li>event.which 标明哪个按钮触发了事件，鼠标和键盘的键标识统一在这个属性中</li>
<li>event.preventDefault()event.isDefaultPrevented() 禁止默认行为</li>
<li>event.stopImmediateProgation()event.isImmediateProgationStopped() 不仅禁止冒泡。还终止绑定函数链的继续进行</li>
<li>event.stopPropagation()，event.isPropagationStopped() 禁止冒泡</li>
<li>event.pageX，event.pageY 事件触发时相对于 document的鼠标位置</li>
<li>event.namespace 事件触发时的名字空间，比如 trigger(‘click.namespace’)</li>
<li>event.data 额外传入的数据</li>
<li>event.result 上一个绑定函数的返回值</li>
<li>event.timeStamp 事件触发时的时间，其值为 (newDate).getTime()</li>
<li>event.type 事件类型</li>
</ul>
<p>如果一个绑定函数最后返回了 false，则默认是 event.preventDefault()和 event.stopPropagation()行为。</p>
<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="请求与回调"><a href="#请求与回调" class="headerlink" title="请求与回调"></a>请求与回调</h2><p>jQuery的AJAX，核心的请求处理函数只有一个，就是 $.ajax()，然后就是一个简单的上层函数。</p>
<p>$.ajax() 的基本使用形式是：</p>
<p>jQuey.ajax(settings) settings是一个对象，里面包含了所有的配置项。</p>
<ul>
<li>url 请求的地址。</li>
<li>type 请求的方法类型， GET， POST。默认是 GET。</li>
<li>data 要发送的数据</li>
<li>dataType 服务器返回的数据类型，支持 xml， html， script， json， jsonp， text</li>
<li>success 请求成功时调用的处理函数 success(data,textStatus,jqXHR)</li>
<li>context 回调函数执行时的上下文</li>
<li>cache 默认为 true，是否为请求单独添加一个随机参数以防止浏览器缓存</li>
<li>error 请求错误时的调用函数。</li>
<li>error(jqXHR,textStatus,errorThrown)</li>
<li>第二个参数是表示请求状态的字符串： timeout， error， abort， parsererror</li>
<li>第三个参数是当HTTP错误发生时，具体的错误描述： NotFound， InternalServerError等</li>
<li>complete 请求结束（无论成功或失败）时的一个回调函数。</li>
<li>complete(jqXHR,textStatus)</li>
<li>第二个参数时表示请求状态的字符串： success， notmodified， error， timeout， abort， parsererror。</li>
<li>jsonp 一个参数名，默认是 callback，一般用于指明回调函数名。设置成 false可以让请求没有 callback参数。</li>
<li>jsonpCallback callback参数值。默认是自动生成的一个随机值。</li>
</ul>
<h2 id="请求的状态"><a href="#请求的状态" class="headerlink" title="请求的状态"></a>请求的状态</h2><p>对于全局的所有AJAX请求而言，可以在任意节点上绑定到全局任意AJAX请求的每一个事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#loading'</span>).ajaxStart(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="keyword">this</span>).show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>.ajaxStart() 请求将要发出时</li>
<li>.ajaxSend() 请求将要发出时（在 .ajaxStart()后）</li>
<li>.ajaxSuccess() 请求成功</li>
<li>.ajaxError() 请求错误</li>
<li>.ajaxComplete() 请求完成</li>
<li>.ajaxStop() 请求结束（在 .ajaxComplete()后）</li>
</ul>
<h2 id="工具函数-1"><a href="#工具函数-1" class="headerlink" title="工具函数"></a>工具函数</h2><ul>
<li>.serialize() 解析表单参数项，返回字符串</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert($(<span class="keyword">this</span>).serialize());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>.serializeArray() 解析表单参数项，返回一个列表对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'form'</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert($(<span class="keyword">this</span>).serializeArray());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h1 id="泛化回调"><a href="#泛化回调" class="headerlink" title="泛化回调"></a>泛化回调</h1><h2 id="Deferred"><a href="#Deferred" class="headerlink" title="Deferred"></a>Deferred</h2><p>Deferred对象是在jQuery1.5中引入的回调管理对象。其作用是把一堆函数按顺序放入一个调用链，然后根据状态来依次调用这些函数。AJAX的所有操作都是使用它来进行封装的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = $.Deferred(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;);</span><br><span class="line">obj.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">obj.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.resolve();</span><br></pre></td></tr></table></figure>
<p>总的来说：jQuery的 Deferred对象有三个状态： done， fail， process。</p>
<ul>
<li>process 只能先于其他两个状态先被激发。</li>
<li>done和 fail互斥，只能激发一个。</li>
<li>process可以被重复激发，而 done和 fail只能激发一次。</li>
</ul>
<p>然后，jQuery提供了一些函数用于添加回调，激发状态等。</p>
<ul>
<li>deferred.done() 添加一个或多个成功回调</li>
<li>deferred.fail() 添加一个或多个失败回调</li>
<li>deferred.always() 添加一个函数，同时应用于成功和失败</li>
<li>deferred.progress() 添加一个函数用于准备回调</li>
<li>deferred.then() 依次接受三个函数，分别用于成功，失败，准备状态</li>
<li>deferred.reject() 激发失败状态</li>
<li>deferred.resolve() 激发成功状态</li>
<li>deferred.notify() 激发准备状态</li>
</ul>
<p>如果一个 Deferred已经被激发，则新添加的对应的函数会被立即执行。<br>jQuery还提供了一个 jQuery.when()的回调管理函数，可以用于方便地管理多个事件并发的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defer = $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'test.html'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;);</span><br><span class="line">defer.done(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>done()做的事和使用 success()定义是一样的。</p>
<p>当我们需要完成，像“请求A和请求B都完成时，执行函数”之类的需求时，使用 $.when()就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defer_1 = $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'json.html'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> defer_2 = $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'jsonp.html'</span>,</span><br><span class="line">    dataType: <span class="string">'jsonp'</span></span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> new_defer = $.when(defer_1, defer_2);</span><br><span class="line">new_defer.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在 $.when()中的 Deferred，只要有一个是 fail，则整体结果为 fail。</p>
<p>Deferred的回调函数的执行顺序与它们的添加顺序一致。</p>
<p>这里特别注意一点，就是 done/fail/always与 then的返回值的区别。从功能上看，它们都可以添加回调函数，但是，方法的返回值是不同的。前组的返回值是原来的那个 defer对象，而 then返回的是一个新的 defer对象。</p>
<p>then返回新的 defer这种形式，可以用于方便地实现异步函数的链式调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">defer.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'/json'</span>,</span><br><span class="line">        dataType: <span class="string">'json'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"inner"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>等同于是调用了两次 defer.done, defer.done ，注册的两次回调函数依次被执行后，看到的输出是： hello， inner。</p>
<p>这是两次 defer.done 的结果，第一个回调函数返回了一个新的 defer 没任何作用。</p>
<p>如果换成 then 方法： defer.then(function(){…});</p>
<p>它跟两次 defer.done 是不同的。 new_defer 会在 inner 那里的 defer 被触发时再被触发，所以输出结果是： inner， hello。</p>
<p>更一般地来说 then 的行为，就是前面的注册函数的返回值，会作为后面注册函数的参数值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> defer = $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/json'</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span></span><br><span class="line">&#125;);</span><br><span class="line">defer.then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码的输入结果是：<code>ajax response</code>，<code>1</code>，<code>2</code>。</p>
<h2 id="Callbacks"><a href="#Callbacks" class="headerlink" title="Callbacks"></a><strong>Callbacks</strong></h2><p>事实上，<code>Deferred</code>机制，只是在<code>Callbacks</code>机制的上层进行了一层简单封装。<code>Callbacks</code>对象才是真正的jQuery中定义的原始的回调管理机制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = $.Callbacks();</span><br><span class="line">obj.add(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">obj.add(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">obj.fire();</span><br></pre></td></tr></table></figure>
<p><code>Callbacks</code>对象的初始化支持一组控制参数：</p>
<p>$.Callbacks(flags) 初始化一个回调管理对象。 flags是空格分割的多个字符串，以定义此回调对象的行为：</p>
<ul>
<li>once 回调链只能被激发一次</li>
<li>memory 回调链被激发后，新添加的函数被立即执行</li>
<li>unique 相同的回调函数只能被添加一次</li>
<li>stopOnFalse 当有回调函数返回 false时终止调用链的执行</li>
</ul>
<p>CallbackS的控制方法：</p>
<ul>
<li>callbacks.add() 添加一个或一串回调函数</li>
<li>callbacks.fire() 激发回调</li>
<li>callbacks.remove() 从调用链中移除指定的函数</li>
<li>callbacks.empty() 清空调用链</li>
<li>callbacks.disable() 关闭调用链的继续执行，新添加的函数也不会被执行</li>
<li>callbacks.lock() 锁定调用链，但是如果打开了 memory的 flag，新添加的函数仍然会执行</li>
<li>callbacks.has() 检查一个函数是否处于回调链之中</li>
<li>callbacks.fired() 检查回调链是否被激发</li>
<li>callbacks.locked() 检查回调链是否被锁定</li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>jquery</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>ASP.NET中的设计模式——原型模式</title>
    <url>/2018/04/24/prototype-pattern/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在工作室课上在讲 .NET 程序开发应该掌握的各种设计模式，恰巧看到设计模式中的原型模式与 JavaScript 中的继承机制——原型链有异曲同工之妙，便深入研究了一下。</p>
<p>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。</p>
<p>现将本人学习心得分享与此以方便大家更好地学习掌握原型模式。</p>
<a id="more"></a>
<h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>当运行以下代码时，会产生什么样的结果呢？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line">Console.WriteLine(a);</span><br></pre></td></tr></table></figure>
<p>答案是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<p>再运行以下代码时，又会产生什么样的结果呢？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Person a = <span class="keyword">new</span> Person(<span class="string">"Jack"</span>,<span class="number">20</span>);</span><br><span class="line">Person b = a;</span><br><span class="line">b.SetInfo(<span class="string">"John"</span>,<span class="number">21</span>);</span><br><span class="line">a.Display();    <span class="comment">// a显示的信息是什么？</span></span><br></pre></td></tr></table></figure>
<p>答案是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">John 21</span><br></pre></td></tr></table></figure>
<p>以上两段代码结构相似，但为何会产生不同的结果呢？</p>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>要明白这个问题，我们先得对 C# 的数据类型有一定的了解。</p>
<p>C# 的数据项类型一共分为以下几种：</p>
<ul>
<li>值类型（Value types）</li>
<li>引用类型（Reference types）</li>
<li>指针类型（Pointer types）(此处不做讨论)</li>
</ul>
<p>而 string 类型是一种具有值类型特性的特殊引用类型,并不是基本数据类型（底下有关于 string 的详细介绍）。值类型和引用类型的区别看下表：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">值类型</th>
<th style="text-align:right">引用类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>内存分配地点</td>
<td style="text-align:center">分配在栈中</td>
<td style="text-align:right">分配在堆中</td>
</tr>
<tr>
<td>效率</td>
<td style="text-align:center">效率高，不需要地址转换</td>
<td style="text-align:right">效率低，需要进行地址转换</td>
</tr>
<tr>
<td>内存回收</td>
<td style="text-align:center">使用完后，立即回收</td>
<td style="text-align:right">垃圾回收机制</td>
</tr>
<tr>
<td>赋值操作</td>
<td style="text-align:center">进行复制，创建一个同值新对象</td>
<td style="text-align:right">只是对原有对象的引用</td>
</tr>
<tr>
<td>函数参数和返回值</td>
<td style="text-align:center">是对象的复制</td>
<td style="text-align:right">是原有对象的引用</td>
</tr>
</tbody>
</table>
<p>通过以下图片我们可以看到对象的值的传递情况</p>
<img src="/2018/04/24/prototype-pattern/p1.png" title="对象的值的传递">
<img src="/2018/04/24/prototype-pattern/p2.png" title="对象的值的传递">
<p>Person b = a 后，即将 a 的值赋值给了 b ，此时 a 和 b 都同时指向同一个堆里，b.SetInfo(“John”,21) 即改变了堆里的值，而 a 的值仍然是从堆里获取，所以 a.Display() 的值为 John 21。</p>
<p>但如何实现如下面两张图一样的数据传递呢？</p>
<img src="/2018/04/24/prototype-pattern/p3.png" title="对象的值的传递">
<img src="/2018/04/24/prototype-pattern/p4.png" title="对象的值的传递">
<p>原型模式告诉你答案！！！</p>
<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="原型模式介绍"><a href="#原型模式介绍" class="headerlink" title="原型模式介绍"></a>原型模式介绍</h2><p>维基百科：原型模式（Prototype Pattern）是创建型模式的一种，其特点在于通过「复制」一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的「原型」（Prototype），这个原型是可定制的。</p>
<h2 id="原型模式的UML类图"><a href="#原型模式的UML类图" class="headerlink" title="原型模式的UML类图"></a>原型模式的UML类图</h2><img src="/2018/04/24/prototype-pattern/p5.png" title="原型模式的UML类图">
<h2 id="原型模式的简单实现"><a href="#原型模式的简单实现" class="headerlink" title="原型模式的简单实现"></a>原型模式的简单实现</h2><p>申明抽象原型类和具体原型类：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象原型类:声明克隆自身的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Prototype <span class="title">Clone</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体原型类:实现克隆的具体操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcretePrototype1</span> : <span class="title">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"ConcretePrototype1 Cloned!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Prototype)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ConcretePrototype2</span> : <span class="title">Prototype</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"ConcretePrototype2 Cloned!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Prototype)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序调用：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 客户类:让一个原型克隆自身，从而获得一个新的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ConcretePrototype1 obj1 = <span class="keyword">new</span> ConcretePrototype1();</span><br><span class="line">        ConcretePrototype1 obj2 = <span class="keyword">new</span> ConcretePrototype2();</span><br><span class="line"></span><br><span class="line">        ConcretePrototype1 cloneObj1 = (ConcretePrototype1)obj1.Clone();</span><br><span class="line">        ConcretePrototype1 cloneObj2 = (ConcretePrototype2)obj2.Clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcreteProtype1 Cloned!</span><br><span class="line">ConcreteProtype2 Cloned!</span><br></pre></td></tr></table></figure>
<h2 id="简历的原型实现"><a href="#简历的原型实现" class="headerlink" title="简历的原型实现"></a>简历的原型实现</h2><p>简历类：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Resume</span> : <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> timeArea;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> company;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resume</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置个人信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetPresonalInfo</span>(<span class="params"><span class="keyword">string</span> sex, <span class="keyword">string</span> age</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置工作经历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetWorkExperience</span>(<span class="params"><span class="keyword">string</span> timeArea, <span class="keyword">string</span> company</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">this</span>.timeArea = timeArea;</span><br><span class="line">        <span class="keyword">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125; &#123;1&#125; &#123;2&#125;"</span>, name, sex, age);</span><br><span class="line">        Console.WriteLine(<span class="string">"工作经历：&#123;0&#125; &#123;1&#125;"</span>, timeArea, company);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Object)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用代码：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Resume a = <span class="keyword">new</span> Resume(<span class="string">"大鸟"</span>)；</span><br><span class="line">    a.SetPersonalInfo(<span class="string">"男"</span>, <span class="string">"29"</span>);  </span><br><span class="line">    a.SetWorkExperience(<span class="string">"1998-2000"</span>, <span class="string">"XX公司"</span>)  </span><br><span class="line">  </span><br><span class="line">    Resume b = （Resume）a.Clone();  </span><br><span class="line">    b.setWorkExperience(<span class="string">"1998-2006"</span>, <span class="string">"YY企业"</span>)  </span><br><span class="line">  </span><br><span class="line">    Resume c = （Resume）a.Clone();  </span><br><span class="line">    c.SetPersonalInfo(<span class="string">"男"</span>, <span class="string">"24"</span>);  </span><br><span class="line">  </span><br><span class="line">    a.Display();</span><br><span class="line">    b.Display();  </span><br><span class="line">    c.Display();  </span><br><span class="line"></span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大鸟 男 29</span><br><span class="line">工作经历  1998-2000  XX公司</span><br><span class="line">大鸟 男 29</span><br><span class="line">工作经历  1998-2006  YY公司</span><br><span class="line">大鸟 男 24</span><br><span class="line">工作经历  1998-2000  XX公司</span><br></pre></td></tr></table></figure>
<h2 id="实现ICloneable接口"><a href="#实现ICloneable接口" class="headerlink" title="实现ICloneable接口"></a>实现ICloneable接口</h2><p>.NET 在 System 命名空间中提供了 ICloneable 接口，其中只包含一个 Clone() 方法，实现了这个接口就是完成了原型模式。</p>
<img src="/2018/04/24/prototype-pattern/p6.png" title="实现ICloneable接口">
<h1 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h1><p>注：string 是一种拥有值类型特点的特殊引用类型！（例：上面简历的原型实现代码）</p>
<ul>
<li>string 不是基本数据类型，而是一个类（class）</li>
<li>class string 继承自对象 （object） ，而不是 System.ValueType ( Int32 这样的则是继承于 System.ValueType) </li>
<li>string 本质上是个 char[]，而 Array 是引用类型，并且初始化时也是在托管堆分配内存的，但是这个特殊的类却表现出值类型的特点，微软设计这个类的时候为了方便操作，所以重写了 == 和 != 操作符以及 Equals 方法，它判断相等性时，是按照内容来判断的，而不是地址</li>
<li>string 在栈上保持引用，在堆上保持数据</li>
</ul>
<h2 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h2><ul>
<li>只复制对象的值类型字段，引用类型只复制引用不复制引用的对象（即复制地址）</li>
<li>MemberwiseClone() 方法是浅拷贝（<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.object.memberwiseclone?view=netframework-4.7.1#System_Object_MemberwiseClone" target="_blank" rel="noopener">微软关于 MemberwiseClone() 的介绍</a>）</li>
</ul>
<img src="/2018/04/24/prototype-pattern/p7.png" title="浅拷贝">
<h3 id="浅拷贝引用类型会出现的错误"><a href="#浅拷贝引用类型会出现的错误" class="headerlink" title="浅拷贝引用类型会出现的错误"></a>浅拷贝引用类型会出现的错误</h3><p>工作经历类</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">Class WorkExperience  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> workDate;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> WorkDate  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> workDate; &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123; workDate = <span class="keyword">value</span>; &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> company;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Company  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> company; &#125;  </span><br><span class="line">        <span class="keyword">set</span> &#123; company = <span class="keyword">value</span>; &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简历类</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Resume</span>:<span class="title">ICloneable</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> sex;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> age;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WorkExperience work;    <span class="comment">// 引用"工作经历"对象  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resume</span>(<span class="params"><span class="keyword">string</span> name</span>)  </span></span><br><span class="line"><span class="function"></span>    &#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        work = <span class="keyword">new</span> WorkExperience();    <span class="comment">// 在“简历”类实例化时同时实例化“工作经历”  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 设置个人信息：  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetPersonalInfo</span>(<span class="params"><span class="keyword">string</span> sex,<span class="keyword">string</span> age</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;  </span><br><span class="line">        <span class="keyword">this</span>.sex = sex;  </span><br><span class="line">        <span class="keyword">this</span>.age = age;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 设置工作经历  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> SetWorkExperience（<span class="keyword">string</span> workDate，<span class="keyword">string</span> company)  </span><br><span class="line">    &#123;  </span><br><span class="line">        work.WorkDate = workDate;  </span><br><span class="line">        work.Company = company;    <span class="comment">// 调用此方法时，给对象的两属性赋值</span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 显示  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>    &#123;  </span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125; &#123;1&#125; &#123;2&#125;"</span>, name, sex, age);  </span><br><span class="line">        Console.WriteLine(<span class="string">"工作经历: &#123;0&#125; &#123;1&#125;"</span>, work.WorkDate, work.Company;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">Clone</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>    &#123;  </span><br><span class="line">        <span class="keyword">return</span> (Object)<span class="keyword">this</span>.MemberwiseClone();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端调用代码</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> Main（<span class="keyword">string</span>[] args）  </span><br><span class="line">&#123;  </span><br><span class="line">    Resume a = <span class="keyword">new</span> Resume(<span class="string">"大鸟"</span>);  </span><br><span class="line">    a.SetPersonalInfo(<span class="string">"男"</span>, <span class="string">"29"</span>);  </span><br><span class="line">    a.SetWorkExperience(<span class="string">"1998-2000"</span>, <span class="string">"XX公司"</span>)  </span><br><span class="line">  </span><br><span class="line">    Resume b = （Resume）a.Clone();  </span><br><span class="line">    b.setWorkExperience(<span class="string">"1998-2006"</span>, <span class="string">"YY企业"</span>)  </span><br><span class="line">  </span><br><span class="line">    Resume c = （Resume）a.Clone();  </span><br><span class="line">    c.SetPersonalInfo(<span class="string">"男"</span>,<span class="string">"24"</span>);  </span><br><span class="line">    c.SetWorkExperience(<span class="string">"1998-2003"</span>, <span class="string">"ZZ企业"</span>);  </span><br><span class="line">  </span><br><span class="line">    a.Display();</span><br><span class="line">    b.Display();  </span><br><span class="line">    c.Display();  </span><br><span class="line"></span><br><span class="line">    Console.Read();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">大鸟 男 29</span><br><span class="line">工作经历  1998-2003  ZZ公司</span><br><span class="line">大鸟 男 29</span><br><span class="line">工作经历  1998-2003  ZZ公司</span><br><span class="line">大鸟 男 24</span><br><span class="line">工作经历  1998-2003  ZZ公司</span><br></pre></td></tr></table></figure>
<p>从结果显示我们可以看到，由于浅复制是浅表复制，所以对于值类型，没什么问题（如 c.Display()）；对于引用类型，只是复制了引用，引用的对象还是指向原来的对象，所以给 a, b, c 三个引用设置‘工作经历’，却同时看到三个引用都是最后一次设置，因为三个引用都指向了同一个对象。</p>
<h2 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h2><ul>
<li>不仅复制值类型字段，而且复制引用的对象</li>
<li>把引用对象的变量指向复制过的新对象，而不是原有的被引用对象</li>
</ul>
<img src="/2018/04/24/prototype-pattern/p8.png" title="深拷贝">
<h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><img src="/2018/04/24/prototype-pattern/p9.png" title="实现深拷贝">
<p>简历和工作经历类：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Resume</span> : <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">private</span> WorkExperience work;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetWorkExperience</span>(<span class="params"><span class="keyword">string</span> workDate, <span class="keyword">string</span> company</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        work.WorkDate = workDate;</span><br><span class="line">        work.Company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">$"<span class="subst">&#123; Name &#125;</span> Worded in <span class="subst">&#123; work.Company &#125;</span> from <span class="subst">&#123; work.WorkDate &#125;</span>."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Resume</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        work = <span class="keyword">new</span> WorkExperience();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有的构造方法，让“工作经历”克隆完成，最终返回一个深复制的简历对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Resume cloned = <span class="keyword">new</span> Resume(<span class="keyword">this</span>.Name);</span><br><span class="line">        cloned.work = (WorkExperience)<span class="keyword">this</span>.work.Clone();  <span class="comment">// 克隆工作经历</span></span><br><span class="line">        <span class="keyword">return</span> cloned;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作经历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">WorkExperience</span> : <span class="title">ICloneable</span>    <span class="comment">// 让“工作经历”实现 ICloneable 接口</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> String WorkDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> String Company &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Clone</span>(<span class="params"></span>)    <span class="comment">// 让“工作经历”类实现克隆方法</span></span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序调用：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Resume resume = <span class="keyword">new</span> Resume(<span class="string">"Jack"</span>);</span><br><span class="line">        resume.SetWorkExperience(<span class="string">"2012-2015"</span>, <span class="string">"XX公司"</span>);</span><br><span class="line"></span><br><span class="line">        Resume cloned = (Resume)resume.Clone();</span><br><span class="line">        cloned.SetWorkExperience(<span class="string">"2015-2018"</span>, <span class="string">"YY公司"</span>);</span><br><span class="line"></span><br><span class="line">        resume.Display();</span><br><span class="line">        cloned.Display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jack worked in XX公司 from 2012-2015</span><br><span class="line">Jack worked in YY公司 from 2015-2018</span><br></pre></td></tr></table></figure>
<h1 id="原型模式的应用"><a href="#原型模式的应用" class="headerlink" title="原型模式的应用"></a>原型模式的应用</h1><h2 id="JavaScript-继承机制——原型链"><a href="#JavaScript-继承机制——原型链" class="headerlink" title="JavaScript 继承机制——原型链"></a>JavaScript 继承机制——原型链</h2><p>参考文章：<a href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html" target="_blank" rel="noopener">阮一峰《Javascript 继承机制的设计思想》</a></p>
<img src="/2018/04/24/prototype-pattern/p10.png" title="JavaScript继承机制——原型链">
<p>JavaScript 的创始人 Brendan Eich 在开发 JavaScript 这个使得浏览器可以与网页互动的脚本易语言时，正是面向对象编程（object-oriented programming）最兴盛的时期，C++ 是当时最流行的语言，而 Java 语言的1.0版即将于第二年推出，Sun公司正在大肆造势。</p>
<p>Brendan Eich 无疑受到了影响，Javascript 里面所有的数据类型都是对象（object），这一点与 Java 非常相似。但是，他随即就遇到了一个难题，到底要不要设计”继承”机制呢？如果真的是一种简易的脚本语言，其实不需要有”继承”机制。但是，Javascript 里面都是对象，必须有一种机制，将所有对象联系起来。所以，Brendan Eich 最后还是设计了”继承”。但是，他不打算引入”类”（class）的概念，因为一旦有了”类”，Javascript 就是一种完整的面向对象编程语言了，这好像有点太正式了，而且增加了初学者的入门难度。他考虑到，C++ 和 Java 语言都使用 new 命令，生成实例。因此，他就把new命令引入了 Javascript，用来从原型对象生成一个实例对象。但是，Javascript 没有”类”，怎么来表示原型对象呢？</p>
<p>这时，他想到 C++ 和 Java 使用 new 命令时，都会调用”类”的构造函数（constructor）。他就做了一个简化的设计，在 Javascript 语言中，new 命令后面跟的不是类，而是构造函数。</p>
<p>举例来说，现在有一个叫做 DOG 的构造函数，表示狗对象的原型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对这个构造函数使用 new，就会生成一个 DOG 对象的实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line">alert(dogA.name);   <span class="comment">// 大毛</span></span><br></pre></td></tr></table></figure>
<p>注意构造函数中的 this 关键字，它就代表了新创建的实例对象。</p>
<p>但是用构造函数生成实例对象，有一个缺点，那就是无法共享属性和方法。比如，在 DOG 对象的构造函数中，设置一个实例对象的共有属性 species。然后，生成两个实例对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">this</span>.name = name;</span><br><span class="line">　　<span class="keyword">this</span>.species = <span class="string">'犬科'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line"><span class="keyword">var</span> dogB = <span class="keyword">new</span> DOG(<span class="string">'二毛'</span>);</span><br></pre></td></tr></table></figure>
<p>这两个对象的 species 属性是独立的，修改其中一个，不会影响到另一个。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dogA.species = <span class="string">'猫科'</span>;</span><br><span class="line">alert(dogB.species);   <span class="comment">// 显示"犬科"，不受dogA的影响</span></span><br></pre></td></tr></table></figure>
<p>考虑到这一点，Brendan Eich 决定为构造函数设置一个 prototype 属性。</p>
<p>这个属性包含一个对象（以下简称”prototype 对象”），所有实例对象需要共享的属性和方法，都放在这个对象里面；那些不需要共享的属性和方法，就放在构造函数里面。</p>
<p>实例对象一旦创建，将自动引用 prototype 对象的属性和方法。也就是说，实例对象的属性和方法，分成两种，一种是本地的，另一种是引用的。</p>
<p>还是以 DOG 构造函数为例，现在用 prototype 属性进行改写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DOG</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">　　<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DOG.prototype = &#123; <span class="attr">species</span> : <span class="string">'犬科'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dogA = <span class="keyword">new</span> DOG(<span class="string">'大毛'</span>);</span><br><span class="line"><span class="keyword">var</span> dogB = <span class="keyword">new</span> DOG(<span class="string">'二毛'</span>);</span><br><span class="line"></span><br><span class="line">alert(dogA.species);   <span class="comment">// 犬科</span></span><br><span class="line">alert(dogB.species);   <span class="comment">// 犬科</span></span><br></pre></td></tr></table></figure>
<p>现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DOG.prototype.species = <span class="string">'猫科'</span>;</span><br><span class="line"></span><br><span class="line">alert(dogA.species);   <span class="comment">// 猫科</span></span><br><span class="line">alert(dogB.species);   <span class="comment">// 猫科</span></span><br></pre></td></tr></table></figure>
<h2 id="数据模型缓存"><a href="#数据模型缓存" class="headerlink" title="数据模型缓存"></a>数据模型缓存</h2><img src="/2018/04/24/prototype-pattern/p11.png" title="数据模型缓存">
<p>实现示例：创建一个抽象类 CloneableModel，并让类 User、Product 来扩展它；然后定义 ModelCache 类，该类把 CloneableModel 对象存储在 HashTable 中，并在请求的时候返回对应类型的克隆对象。</p>
<img src="/2018/04/24/prototype-pattern/p12.png" title="数据模型缓存">
<p>CloneableModel类定义及扩展：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可克隆模型</span></span><br><span class="line"><span class="comment">// 实现 ICloneable 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CloneableModel</span> : <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">object</span> <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.MemberWiseClone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">User</span> : <span class="title">CloneableModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Product</span> : <span class="title">CloneableModel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Price &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ModelICache类定义：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModelCache</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> Hashtable modelMap = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将模型类对象存储到 Hashtable 中</span></span><br><span class="line">    <span class="comment">// 实际开发中，模型对象从数据库中取出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Load</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User &#123; </span><br><span class="line">            Id = <span class="string">"#1001"</span>, </span><br><span class="line">            Name = <span class="string">"John Doe"</span> </span><br><span class="line">        &#125;;</span><br><span class="line">        modelMap.Add(user.Id, user);</span><br><span class="line"></span><br><span class="line">        Product product = <span class="keyword">new</span> Product &#123; </span><br><span class="line">            Id = <span class="string">"#2001"</span>, </span><br><span class="line">            Name = <span class="string">"Illustrated C# 2012"</span>, </span><br><span class="line">            Price = <span class="string">"￥89.00"</span> </span><br><span class="line">        &#125;;</span><br><span class="line">        modelMap.Add(product.Id, product);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Db Models Cache loading ... Down!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static T GetModel&lt;T&gt;(string id) where T : class, new()</span><br><span class="line">    &#123;</span><br><span class="line">        CloneableModel cache = (CloneableModel)modelMap[id];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cache != <span class="literal">null</span></span><br><span class="line">            ? (T)cache.Clone()    <span class="comment">// 从 cache 中克隆 model</span></span><br><span class="line">            : <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主程序调用：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        ModelCache.Load();</span><br><span class="line"></span><br><span class="line">        User userCloned = ModelCache.GetModel&lt;User&gt;(<span class="string">"#1001"</span>);</span><br><span class="line">        Product productCloned = ModelCache.GetModel&lt;Product&gt;(<span class="string">"#2001"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (userCloned == <span class="literal">null</span> || productCloned == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">$"ID: <span class="subst">&#123; userCloned.Id &#125;</span> Name: <span class="subst">&#123; userCloned.Name &#125;</span>"</span>);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            <span class="string">$"ID: <span class="subst">&#123; productCloned.Id &#125;</span> Name: <span class="subst">&#123; productCloned.Name &#125;</span> Price: <span class="subst">&#123; productCloned.Price &#125;</span>"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Db Models Cache Loading ... Down!</span><br><span class="line">ID: <span class="meta">#1001 Name: John Doe</span></span><br><span class="line">ID: <span class="meta">#2001 Name: Illustrated C# 2012 Price: ￥89.00</span></span><br></pre></td></tr></table></figure>
<h1 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>隐藏了对象的创建细节，对有些初始化需要占用很多资源的类来说，对性能也有很大提高。</li>
<li>在需要新对象时，可以使用Clone来快速创建创建一个，而不用使用new来构建。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>每一个类都需要一个Clone方法，而且必须通盘考虑。对于深拷贝来说，每个关联到的类型都不许实现IClonable接口，并且每增加或修改一个字段是都需要更新Clone方法。</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>资源优化场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ul>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>ASP.NET</tag>
        <tag>C#</tag>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
        <tag>原型链</tag>
        <tag>Hashtable</tag>
      </tags>
  </entry>
  <entry>
    <title>es6</title>
    <url>/2018/12/15/es6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这篇文章的出发点是为了帮助前端开发者串联 ES6前后的 JavaScript 知识，并且可以快速了解 JavaScript 语言的最新进展。</p>
<a id="more"></a>
<p>JavaScript 在当下处于特权地位，因为它是唯一可以在浏览器中运行的语言，并且是被高度集成和优化过的。</p>
<p>JavaScript 在未来有着极好的发展空间，跟上它的变化不会比现在更加的困难。我的目标是让你能够快速且全面的了解这门语言可以使用的新内容。</p>
<h1 id="ECMAScript-简介"><a href="#ECMAScript-简介" class="headerlink" title="ECMAScript 简介"></a>ECMAScript 简介</h1><p>每当阅读 JavaScript 相关的文章时，我都会经常遇到如下术语： ES3, ES5, ES6, ES7, ES8, ES2015, ES2016, ES2017, ECMAScript 2017, ECMAScript 2016, ECMAScript 2015 等等，那么它们是指代的是什么？</p>
<p>它们都是指代一个名为 ECMAScript 的标准。</p>
<p>JavaScript 就是基于这个标准实现的，ECMAScript 经常缩写为 ES。</p>
<p>除了 JavaScript 以外，其它基于 ECMAScript 实现语言包括：</p>
<p>ActionScript ( Flash 脚本语言)，由于 Adobe 将于 2020 年末停止对 Flash 的支持而逐渐失去热度。</p>
<p>JScript (微软开发的脚本语言),在第一次浏览器大战最激烈的时期，JavaScript 只被Netscape所支持，微软必须为 Internet Explorer 构建自己的脚本语言。</p>
<p>但是现在流传最广、影响最大的基于 ES 标准的语言实现无疑就是 JavaScript了</p>
<p>为啥要用这个奇怪的名字呢？Ecma International 是瑞士标准协会，负责制定国际标准。</p>
<p>JavaScript 被创建以后，经由 Netscape 和 Sun Microsystems 公司提交给欧洲计算机制造商协会进行标准化，被采纳的 ECMA-262 别名叫 ECMAScript。</p>
<p>This press release by Netscape and Sun Microsystems (the maker of Java) might help figure out the name choice, which might include legal and branding issues by Microsoft which was in the committee, according to Wikipedia.</p>
<p>IE9 之后微软的浏览器中就看不到对 JScript 这个命名的引用了，取而代之都统称为 JavaScript。</p>
<p>因此，截至201x，JavaScript 成为最流行的基于 ECMAScript 规范实现的语言。</p>
<h1 id="ECMAScript-当前的版本"><a href="#ECMAScript-当前的版本" class="headerlink" title="ECMAScript 当前的版本"></a>ECMAScript 当前的版本</h1><p>目前的最新的 ECMAScript 版本是 ES2018。</p>
<p>于 2018 年 6 月发布。</p>
<h1 id="TC39-是什么"><a href="#TC39-是什么" class="headerlink" title="TC39 是什么"></a>TC39 是什么</h1><p>TC39（Technical Committee 39）是一个推动 JavaScript 发展的委员会。</p>
<p>TC39的成员包括各个主流浏览器厂商以及业务与浏览器紧密相连的公司，其中包括 Mozilla，Google ，Facebook，Apple，Microsoft，Intel，PayPal，SalesForce等。</p>
<p>每个标准版本提案都必须经过四个不同的阶段，这里有详细的解释。</p>
<p>ES Versions</p>
<p>令我费解的是 ES 版本的命名依据有时根据迭代的版本号，有时却根据年份来进行命名。而这个命名的不确定性又使得人们更加容易混淆 JS/ES 这个两个概念😄。</p>
<p>在 ES2015 之前，ECMAScript 各个版本的命名规范通常与跟着标准的版本更新保持一致。因此，2009年 ECMAScript 规范更新以后的的正式版本是 ES5。</p>
<p>Why does this happen? During the process that led to ES2015, the name was changed from ES6 to ES2015, but since this was done late, people still referenced it as ES6, and the community has not left the edition naming behind — the world is still calling ES releases by edition number.</p>
<p>为什么会发生这一切？在ES2015诞生的过程中，名称由ES6更改为ES2015，但由于最终完成太晚，人们仍然称其为ES6，社区也没有将版本号完全抛之于后 — 世界仍然使用 ES 来定义版本号。</p>
<h1 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a>let和const</h1><p>ES2015 之前, var 是唯一可以用来声明变量的语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上面语句如果你遗漏了 var，那么你会把这个值（0）赋给一个未声明的变量，其中声明和未声明变量之间存在一些差异。</p>
<p>在现代浏览器开启严格模式时，给未声明的变量赋值会抛出 ReferenceError 异常，在较老的浏览器（或者禁用严格模式）的情况下，未声明的变量在执行赋值操作时会隐式的变为全局对象的属性。</p>
<p>当你声明一个变量却没有进行初始化，那么它的值直到你对它进行赋值操作之前都是 undefined 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="comment">//typeof a === 'undefined'</span></span><br></pre></td></tr></table></figure>
<p>你可以对一个变量进行多次重新声明，并覆盖它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>你也可以在一条声明语句中一次声明多个变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>作用域是变量可访问的代码部分。</p>
<p>在函数之外用 var 声明的会分配给全局对象，这种变量可以在全局作用域中被访问到。而在函数内部声明的变量只能在函数局部作用域被访问到，这类似于函数参数。</p>
<p>在函数中定义的局部变量名如何跟全局变量重名，那么局部变量的优先级更高，在函数内无法访问到同名的全局变量。</p>
<p>需要注意的是，var 是没有块级作用域（标识符是一对花括号）的，但是 var 是有函数作用域的，所以在新创建的块级作用域或者是函数作用域里面声明变量会覆盖全局同名变量，因为 var 在这两种情况下没有创建新的作用域。</p>
<p>在函数内部，其中定义的任何变量在所有函数代码中都是可见的，因为JavaScript在执行代码之前实际上将所有变量都移到了顶层（被称为悬挂的东西）。 在函数的内部定义的变量在整个函数作用域中都是可见（可访问），即使变量是在函数体末尾被声明，但是仍然可以再函数体开头部分被引用，因为 JavaScript存在变量提升机制。为避免混淆，请在函数开头声明变量，养成良好的编码规范。</p>
<h2 id="Using-let"><a href="#Using-let" class="headerlink" title="Using let"></a>Using let</h2><p>let 是ES2015中引入的新功能，它本质上是具有块级作用域的 var 。它可以被当前作用域（函数以及块级作用域）以及子级作用域访问到。</p>
<p>现代 JavaScript 开发者在 let 和 var 的选择中可能会更倾向于前者。</p>
<p>如果 let 看起来是一个很抽象的术语，当你阅读到 let color = ‘red’ 这一段，因为使用 let 定义了color 为红色，那么这一切就变的有意义了。</p>
<p>在任何函数之外用 let 声明变量，和 var相反的是 它并不会创建全局变量。</p>
<h2 id="Using-const"><a href="#Using-const" class="headerlink" title="Using const"></a>Using const</h2><p>使用变量 var 或 let 声明的变量可以被重新赋值。 使用 const 声明的变量一经初始化，它的值就永远不能再改变，即不可重新被赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">'test'</span></span><br></pre></td></tr></table></figure>
<p>我们不能再为 a 进行赋值操作。然而，a 如果它是一个具有属性或者方法的对象，那么我们可以改变它的属性或者方法。</p>
<p>const 并不意味着具有不可变性，只是保证用 const 声明的变量的引用地址不被变更。</p>
<p>类似于 let，const 也具有块级作用域。</p>
<p>现代 JavaScript 开发者在遇到不会进行二次赋值的变量声明时，应该尽量使用 const。</p>
<h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>箭头函数的引入极大的改变了代码的书写风格和一些工作机制。</p>
<p>在我看来，箭头函数很受开发者欢迎，现在很少在比较新的代码库中看到 function 关键字了，虽然它并未被废弃。</p>
<p>箭头函数看起来会更加的简洁，因为它允许你使用更短的语法来书写函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果函数体中只包含一条语句，你甚至可以省略大括号并直接书写这条语句：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> doSomething()</span><br></pre></td></tr></table></figure>
<p>参数在括号中传递：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function">(<span class="params">param1, param2</span>) =&gt;</span> doSomething(param1, param2)</span><br></pre></td></tr></table></figure>
<p>如果该函数只有一个参数，那么可以省略掉括号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">param</span> =&gt;</span> doSomething(param)</span><br></pre></td></tr></table></figure>
<p>由于这种简短的语法，使得我们可以更便捷的使用比较简短的函数</p>
<h2 id="隐式返回"><a href="#隐式返回" class="headerlink" title="隐式返回"></a>隐式返回</h2><p>箭头函数支持隐式返回：可以正常的 return 一个返回值但是可以不使用 return 关键字。</p>
<p>隐式返回只在函数体内只包含一条语句的情况下生效：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'test'</span></span><br><span class="line">myFunction() <span class="comment">//'test'</span></span><br></pre></td></tr></table></figure>
<p>需要注意的一种情况，当返回一个对象时，记得将大括号括在括号中以避免产生歧义，误将其（大括号）解析为函数体的大括号。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunction = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">value</span>:<span class="string">'test'</span> &#125;)</span><br><span class="line">myFunction() <span class="comment">//&#123;value: 'test'&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h2><p>this 可能是一个很难掌握的概念，因为它会根据上下文而进行变化，并且会在不同的 JavaScript的模式（是否为严格模式）下表现出差异。</p>
<p>理解 this 这个概念对于箭头函数的使用很重要，因为与常规函数相比，箭头函数的表现非常不同。</p>
<p>对象的方法为常规函数时，方法中的this指向这个对象，因此可以这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  model:<span class="string">'Fiesta'</span>,</span><br><span class="line">  manufacturer:<span class="string">'Ford'</span>,</span><br><span class="line">  fullName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.manufacturer&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 car.fullName() 会返回 “Ford Fiesta”。</p>
<p>如果上述方法使用是是箭头函数，由于箭头中的 this 的作用域继承自执行上下文，箭头函数自身不绑定 this，因此 this 的值将在调用堆栈中查找，因此在此代码 car.fullName() 中不会返回常规函数那样的结果，实际会返回字符串 “undefined undefined”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">  model:<span class="string">'Fiesta'</span>,</span><br><span class="line">  manufacturer:<span class="string">'Ford'</span>,</span><br><span class="line">  fullName:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.manufacturer&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.model&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，箭头函数不适合作为对象方法。</p>
<p>同样，箭头函数也不适合使用在作为创建构造函数，因为在实例化对象时会抛出 TypeError。</p>
<p>所以在不需要动态上下文时请使用常规函数。</p>
<p>当然，在事件监听器上使用箭头函数也会存在问题。因为 DOM 事件侦听器会自动将 this 与目标元素绑定，如果该事件处理程序的逻辑依赖 this，那么需要常规函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>)</span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// this === window</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> link = <span class="built_in">document</span>.querySelector(<span class="string">'#link'</span>)</span><br><span class="line">link.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this === link</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="Classes类"><a href="#Classes类" class="headerlink" title="Classes类"></a>Classes类</h1><p>JavaScript 实现继承的方式比较罕见：原型继承。原型继承虽然在我看来很棒，但与其它大多数流行的编程语言的继承实现机制不同，后者是基于类的。</p>
<p>因此 Java、Python 或其它语言的开发者很难理解原型继承的方式，因此 ECMAScript 委员会决定在原型继承之上实现 class 的语法糖，这样便于让其它基于类实现继承的语言的开发者更好的理解 JavaScript 代码。</p>
<p>注意：class 并没有对 JavaScript 底层做修改，你仍然可以直接访问对象原型。</p>
<h2 id="class-定义"><a href="#class-定义" class="headerlink" title="class 定义"></a>class 定义</h2><p>如下是一个 class 的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, I am '</span> + <span class="keyword">this</span>.name + <span class="string">'.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>class 具有一个标识符，我们可以使用 new ClassIdentifier() 来创建一个对象实例。</p>
<p>初始化对象时，调用 constructor方法，并将参数传递给此方法。</p>
<p>类声明语句中也可以增加类需要的一些原型方法。在这种情况下 hello 是 Person 类的一个原型方法，可以在这个类的对象实例上调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flavio = <span class="keyword">new</span> Person(<span class="string">'Flavio'</span>)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure>
<h2 id="Class-继承"><a href="#Class-继承" class="headerlink" title="Class 继承"></a>Class 继承</h2><p>一个子类可以 extend 另一个类，通过子类实例化出来的对象可以继承这两个类的所有方法。</p>
<p>如果子类中的方法与父类中的方法名重复，那么子类中的同名方法优先级更高：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  hello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">' I am a programmer.'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> flavio = <span class="keyword">new</span> Programmer(<span class="string">'Flavio'</span>)</span><br><span class="line">flavio.hello()</span><br></pre></td></tr></table></figure>
<p>(上述代码会打印出：“Hello, I am Flavio. I am a programmer.”)</p>
<p>类没有显示的类变量声明，但你必须在初始化构造函数 constructor 中去初始化类成员变量。</p>
<p>在子类中，你可以通过调用super()引用父类。</p>
<p>静态方法</p>
<p>在类中，通常会把方法直接挂载到实例对象上，直接在实例对象上调用。</p>
<p>而静态方法则是直接使用类名来调用，而不是通过对象实例调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> genericHello() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.genericHello() <span class="comment">//Hello</span></span><br></pre></td></tr></table></figure>
<h1 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h1><p>JavaScript 没有内置真正意义上的受保护的私有方法。</p>
<p>社区有解决方法，但我不会在这里做讲解。</p>
<h1 id="Getters-和-setters"><a href="#Getters-和-setters" class="headerlink" title="Getters 和 setters"></a>Getters 和 setters</h1><p>你可以通过增加方法 前缀 get 或者 set 创建一个 getter 和 setter，getter 和 setter会在你去获取特定值或者修改特定值的时候执行 get 或者 set内的相关方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你只有 getter，该属性无法被设置，并且设置此属性的操作都会被忽略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你只有一个 setter，则可以更改该值，但不能从外部访问它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> name(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>._name = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p>函数 doSomething 接收一个 param1 参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以给 param1 设定默认值，如果在调用函数时未传入参数，那么该参数自动设定未默认值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1 = <span class="string">'test'</span></span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这种机制同样适用于多个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">param1 = <span class="string">'test'</span>, param2 = <span class="string">'test2'</span></span>) =&gt;</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假如你的函数是一个具有特定属性的对象该怎么处理？</p>
<p>曾几何时，如果我们必须要取一个对象的特定属性值，为了做兼容处理（对象格式不正确），你必须在函数中添加一些代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colorize = <span class="function">(<span class="params">options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!options) &#123;</span><br><span class="line">    options = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> color = (<span class="string">'color'</span> <span class="keyword">in</span> options) ? options.color :<span class="string">'yellow'</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过解构，你可以给特定属性提供默认值，如此可以大大简化代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> colorize = <span class="function">(<span class="params">&#123; color = <span class="string">'yellow'</span> &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在调用 colorize 函数时没有传递任何对象，我们同样可以得到一个默认对象作为参数以供使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> spin = <span class="function">(<span class="params">&#123; color = <span class="string">'yellow'</span> &#125; = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><p>模板字符串不同于 ES5 以前的版本，你可以用新颖的方式使用字符串。</p>
<p>这个语法看起来非常简便，只需要使用一个反引号替换掉单引号或双引号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a_string = <span class="string">`something`</span></span><br></pre></td></tr></table></figure>
<p>这个用法是独一无二的，因为它提供了许多普通字符串所没有的功能，如下：</p>
<p>它为定义多行字符串提供了一个很好的语法<br>它提供了一种在字符串中插入变量和表达式的简单方法<br>它允许您创建带有模板标签的DSL (DSL意味着领域特定语言，例如：就如同在 React 中使用 styled-components 定义你组件的 CSS 一样)</p>
<p>下面让我们深入每个功能的细节。</p>
<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>在 ES6 标准之前，创建跨越两行的字符串只能在一行的结尾使用 ‘’ 字符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string =</span><br><span class="line">  <span class="string">'first part</span></span><br><span class="line"><span class="string">second part'</span></span><br></pre></td></tr></table></figure>
<p>这样使得你创建的字符串虽然跨越了两汉，但是渲染时仍然表现成一行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">first part second part</span><br></pre></td></tr></table></figure>
<p>需要渲染为多行的话，需要在一行结尾添加 ‘ ’，比如这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string =</span><br><span class="line">  <span class="string">'first line</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">second line'</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">'first line</span></span><br><span class="line"><span class="string">'</span>+ <span class="string">'second line'</span></span><br></pre></td></tr></table></figure>
<p>模板字符串使得定义多行字符串变得更加简便。</p>
<p>一个模板字符串由一个反引号开始，你只需要按下回车键来创建新的一行，不需要插入特殊符号，最终的渲染效果如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`Hey</span></span><br><span class="line"><span class="string">this</span></span><br><span class="line"><span class="string">string</span></span><br><span class="line"><span class="string">is awesome!`</span></span><br></pre></td></tr></table></figure>
<p>需要特别留意空格在这里是有特殊意义的，如果这样做的话：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`First</span></span><br><span class="line"><span class="string">                Second`</span></span><br></pre></td></tr></table></figure>
<p>那么它会创建出像下面的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">First</span><br><span class="line">                Second</span><br></pre></td></tr></table></figure>
<p>有一个简单的方法可以修复这个问题，只需要将第一行置为空，然后添加了右边的翻译好后调用一个 trim() 方法，就可以消除第一个字符前的所有空格：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`</span></span><br><span class="line"><span class="string">First</span></span><br><span class="line"><span class="string">Second`</span>.trim()</span><br></pre></td></tr></table></figure>
<h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>模板字符串提供了插入变量和表达式的便捷方法</p>
<p>你只需要使用 ${…} 语法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">var</span> = <span class="string">'test'</span></span><br><span class="line"><span class="keyword">const</span> string = <span class="string">`something <span class="subst">$&#123;<span class="keyword">var</span>&#125;</span>`</span> <span class="comment">//something test</span></span><br></pre></td></tr></table></figure>
<p>在 ${} 里面你可以加入任何东西，甚至是表达式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`something <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&#125;</span>`</span></span><br><span class="line"><span class="keyword">const</span> string2 = <span class="string">`something <span class="subst">$&#123;foo() ? <span class="string">'x'</span> : <span class="string">'y'</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<h2 id="Template-tags"><a href="#Template-tags" class="headerlink" title="Template tags"></a>Template tags</h2><p>标记模板可能是一个听起来不太有用的功能，但它实际上被许多流行的库使用，如 Styled Components 、Apollo 、GraphQL客户端/服务器库，因此了解它的工作原理至关重要。</p>
<p>在 Styled Components 模板标签中用于定义CSS字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = styled.button<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 1.5em;</span></span><br><span class="line"><span class="string">  background-color: black;</span></span><br><span class="line"><span class="string">  color: white;</span></span><br></pre></td></tr></table></figure>
<p>在 Apollo 中，模板标签用于定义 GraphQL 查询模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = gql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    ...</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>上面两个例子中的styled.button和gql模板标签其实都是函数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gql</span>(<span class="params">literals, ...expressions</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数返回一个字符串，可以是任意类型的计算结果。</p>
<p>字面量(literals)是一个包含了表达式插值的模板字面量的序列。 表达式(expressions)包含了所有的插值。</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`something <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&#125;</span>`</span></span><br></pre></td></tr></table></figure>
<p>这个例子里面的字面量是由2个部分组成的序列。第1部分就是something，也就是第一个插值位置(${})之前的字符串，第2部分就是一个空字符串，从第1个插值结束的位置直到字符串的结束。</p>
<p>这个例子里面的表达式就是只包含1个部分的序列，也就是6。</p>
<p>举一个更复杂的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> string = <span class="string">`something</span></span><br><span class="line"><span class="string">another <span class="subst">$&#123;<span class="string">'x'</span>&#125;</span></span></span><br><span class="line"><span class="string">new line <span class="subst">$&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>&#125;</span></span></span><br><span class="line"><span class="string">test`</span></span><br></pre></td></tr></table></figure>
<p>这个例子里面的字面量的序列里面，第1个部分是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="string">`something</span></span><br><span class="line"><span class="string">another `</span></span><br></pre></td></tr></table></figure>
<p>第2部分是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="string">`</span></span><br><span class="line"><span class="string">new line `</span></span><br></pre></td></tr></table></figure>
<p>第3部分是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;<span class="string">`</span></span><br><span class="line"><span class="string">test`</span></span><br></pre></td></tr></table></figure>
<p>这个例子里面的表达式包含了2个部分：x和6。</p>
<p>拿到了这些值的函数就可以对其做任意处理，这就是这个特性的威力所在。</p>
<p>比如最简单的处理就是字符串插值，把字面量和表达式拼接起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interpolated = interpolate<span class="string">`I paid <span class="subst">$&#123;<span class="number">10</span>&#125;</span>€`</span></span><br></pre></td></tr></table></figure>
<p>插值的过程就是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interpolate</span>(<span class="params">literals, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> string = <span class="string">``</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [i, val] <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">    string += literals[i] + val</span><br><span class="line">  &#125;</span><br><span class="line">  string += literals[literals.length - <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>给定一个object，你可以抽取其中的一些值并且赋值给命名的变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  firstName:<span class="string">'Tom'</span>,</span><br><span class="line">  lastName:<span class="string">'Cruise'</span>,</span><br><span class="line">  actor:<span class="literal">true</span>,</span><br><span class="line">  age:<span class="number">54</span>, <span class="comment">//made up</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123;<span class="attr">firstName</span>: name, age&#125; = person</span><br></pre></td></tr></table></figure>
<p>name和age就包含了对应的值。</p>
<p>这个语法同样可以用到数组当中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> [first, second] = a</span><br></pre></td></tr></table></figure>
<p>下面这个语句创建了3个新的变量，分别取的是数组a的第0、1、4下标对应的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, second, , , fifth] = a</span><br></pre></td></tr></table></figure>
<h2 id="更强大的对象字面量"><a href="#更强大的对象字面量" class="headerlink" title="更强大的对象字面量"></a>更强大的对象字面量</h2><p>ES2015赋予了对象字面量更大的威力。</p>
<p>简化了包含变量的语法<br>原来的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> something = <span class="string">'y'</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  something: something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> something = <span class="string">'y'</span></span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p>原型可以这样指定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> anObject = &#123; <span class="attr">y</span>:<span class="string">'y'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  __proto__: anObject</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">super</span>()</span><br><span class="line"><span class="keyword">const</span> anObject = &#123; <span class="attr">y</span>:<span class="string">'y'</span>, <span class="attr">test</span>:<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'zoo'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  __proto__: anObject,</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.test() + <span class="string">'x'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">x.test() <span class="comment">//zoox</span></span><br></pre></td></tr></table></figure>
<h1 id="动态属性"><a href="#动态属性" class="headerlink" title="动态属性"></a>动态属性</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'_'</span> + <span class="string">'b'</span>]:<span class="string">'z'</span></span><br><span class="line">&#125;</span><br><span class="line">x.a_b <span class="comment">//z</span></span><br></pre></td></tr></table></figure>
<h1 id="For-of循环"><a href="#For-of循环" class="headerlink" title="For-of循环"></a>For-of循环</h1><p>2009年的ES5引入了forEach()循环。虽然很好用，但是它跟for循环一样，没法break。</p>
<p>ES2015引入了for-of 循环，就是在forEach的基础上加上了break的功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//iterate over the value</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//get the index as well, using `entries()`</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [i, v] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index) <span class="comment">//index</span></span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>留意一下const的使用。这个循环在每次迭代中都会创建一个新的作用域，所以我们可以使用const来代替let。</p>
<p>它跟for…in的区别在于：</p>
<p>for…of遍历属性值<br>for…in遍历属性名</p>
<h1 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h1><p>promise的一般定义： 它是一个代理，通过它可以最终得到一个值.</p>
<p>Promise是处理异步代码的一种方式，可以少写很多回调。</p>
<p>异步函数是建立在promise API上面的，所以理解Promise是一个基本的要求。</p>
<h2 id="promise的原理简述"><a href="#promise的原理简述" class="headerlink" title="promise的原理简述"></a>promise的原理简述</h2><p>一个promise被调用的时候，首先它是处于pending状态。在promise处理的过程中，调用的函数（caller）可以继续执行，直到promise给出反馈。</p>
<p>此时，调用的函数等待的promise结果要么是resolved状态，要么是rejected状态。但是由于JavaScript是异步的，所以promise处理的过程中，函数会继续执行。</p>
<h2 id="为什么JS-API使用promises"><a href="#为什么JS-API使用promises" class="headerlink" title="为什么JS API使用promises"></a>为什么JS API使用promises</h2><p>除了你的代码和第三方库的代码之外，promise在用在现代的Web API中，比如：</p>
<ul>
<li>电池API</li>
<li>Fetch API</li>
<li>Service Workers</li>
</ul>
<p>在现代的JavaScript中，不使用promise是不太可能的，所以我们来深入研究下promise吧。</p>
<h2 id="创建一个promise"><a href="#创建一个promise" class="headerlink" title="创建一个promise"></a>创建一个promise</h2><p>Promise API暴露了一个Promise构造函数，可以通过new Promise()来初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> done = <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">const</span> workDone = <span class="string">'Here is the thing I built'</span></span><br><span class="line">    resolve(workDone)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> why = <span class="string">'Still working on something else'</span></span><br><span class="line">    reject(why)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>promise会检查done这个全局变量，如果为true，就返回一个resolved promise，否则就返回一个rejected promise。</p>
<p>通过resolve和reject，我们可以得到一个返回值，返回值可以是字符串也可以是对象。</p>
<h2 id="使用一个promise"><a href="#使用一个promise" class="headerlink" title="使用一个promise"></a>使用一个promise</h2><p>上面讲了怎么创建一个promise，下面就讲怎么使用（consume）这个promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isItDoneYet = <span class="keyword">new</span> <span class="built_in">Promise</span>()</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> checkIfItsDone = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  isItDoneYet</span><br><span class="line">    .then(<span class="function"><span class="params">ok</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(ok)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行checkIfItsDone()方法时，会执行isItDoneYet()这个promise，并且等待它resolve的时候使用then回调，如果有错误，就用catch回调来处理。</p>
<h2 id="链式promise"><a href="#链式promise" class="headerlink" title="链式promise"></a>链式promise</h2><p>一个promise可以返回另一个promise，从而创建promise链条（chain）。</p>
<p>一个很好的例子就是Fetch API，它是基于XMLHttpRequest API的一个上层API，我们可以用它来获取资源，并且在获取到资源的时候链式执行一系列promise。</p>
<p>Fetch API是一个基于promise的机制，调用fetch()相当于使用new Promise()来声明我们自己的promise。</p>
<h2 id="链式promise的例子"><a href="#链式promise的例子" class="headerlink" title="链式promise的例子"></a>链式promise的例子</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> status = <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status &gt;= <span class="number">200</span> &amp;&amp; response.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(response.statusText))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> json = <span class="function"><span class="params">response</span> =&gt;</span> response.json()</span><br><span class="line">fetch(<span class="string">'/todos.json'</span>)</span><br><span class="line">  .then(status)</span><br><span class="line">  .then(json)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request failed'</span>, error)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>在这个例子当中，我们调用fetch()，从根目录的todos.json文件中获取一系列的TODO项目，并且创建一个链式promise。</p>
<p>运行fetch()方法会返回一个response，它包含很多属性，我们从中引用如下属性：</p>
<p>status, 一个数值，表示HTTP状态码<br>statusText, 一个状态消息，当请求成功的时候返回OK<br>response还有一个json()方法，它返回一个promise，返回内容转换成JSON后的结果。</p>
<p>所以这些promise的调用过程就是：第一个promise执行一个我们定义的status()方法，检查response status，判断是否一个成功的响应(status在200和299之间)，如果不是成功的响应，就reject这个promise。</p>
<p>这个reject操作会导致整个链式promise跳过后面的所有promise直接到catch()语句，打印Request failed和错误消息。</p>
<p>如果这个promise成功了，它会调用我们定义的json()函数。因为前面的promise成功之后返回的response对象，我们可以拿到并作为第2个promise的参数传入。</p>
<p>在这个例子里面，我们返回了JSON序列化的数据，所以第3个promise直接接收这个JSON：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Request succeeded with JSON response'</span>, data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后我们把它打印到console。</p>
<h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>在上一节的的例子里面，我们有一个catch接在链式promise后面。</p>
<p>当promise链中的任意一个出错或者reject的时候，就会直接跳到promise链后面最近的catch()语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'Error'</span>)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="级联错误"><a href="#级联错误" class="headerlink" title="级联错误"></a>级联错误</h2><p>如果在catch()里面抛出一个错误，你可以在后面接上第二个catch()来处理这个错误，以此类推。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="组织多个promise"><a href="#组织多个promise" class="headerlink" title="组织多个promise"></a>组织多个promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all()</span><br></pre></td></tr></table></figure>
<p>如果你要同时完成不同的promise,可以用Promise.all()来声明一系列的promise，然后当它们全部resolve的时候再执行一些操作。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f1 = fetch(<span class="string">'/something.json'</span>)</span><br><span class="line"><span class="keyword">const</span> f2 = fetch(<span class="string">'/something2.json'</span>)</span><br><span class="line"><span class="built_in">Promise</span>.all([f1, f2])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Array of results'</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>结合ES2015的解构赋值语法，你可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([f1, f2]).then(<span class="function">(<span class="params">[res1, res2]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Results'</span>, res1, res2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当然这不限于使用fetch， 这适用于任何promise.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race()</span><br></pre></td></tr></table></figure>
<p>Promise.race()运行所有传递进去的promise，但是只要有其中一个resolve了，就会运行回调函数，并且只执行一次回调，回调的参数就是第一个resolve的promise返回的结果。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseOne = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">500</span>, <span class="string">'one'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promiseTwo = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">'two'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.race([promiseOne, promiseTwo]).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// 'two'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>ES Module是用于处理模块的ECMAScript标准。</p>
<p>虽然 Node.js 多年来一直使用 CommonJS标准，但浏览器却从未有过模块系统，因为模块系统的决策首先需要 ECMAScript 标准化后才由浏览器厂商去实施实现。</p>
<p>这个标准化已经完成在 ES2015中，浏览器也开始实施实现这个标准，大家试图保持一致，以相同的方式工作。现在 ES Module 可以在 Chrome Safari Edge 和 Firefox（从60版本开始） 中使用。</p>
<p>模块非常酷，他们可以让你封装各种各样的功能，同时将这些功能作为库暴露给其它 JavaScript 文件使用。</p>
<h2 id="ES-模块语法"><a href="#ES-模块语法" class="headerlink" title="ES 模块语法"></a>ES 模块语法</h2><p>引入模块的语法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package <span class="keyword">from</span> <span class="string">'module-name'</span></span><br></pre></td></tr></table></figure>
<p>CommonJS 则是这样使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> package = <span class="built_in">require</span>(<span class="string">'module-name'</span>)</span><br></pre></td></tr></table></figure>
<p>一个模块是一个 JavaScript 文件，这个文件使用 export 关键字 导出 一个或多个值（对象、函数或者变量）。例如，下面这个模块提供了一个将字符串变成大写形式的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uppercase.js</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure>
<p>在这个例子中，这个模块定义了唯一一个 default export，因此可以是一个匿名函数。否则，需要一个名称来和其它 导出 做区分。</p>
<p>现在，任何其它的 JavaScript 模块 可以通过 import 导入 uppercase.js 的这个功能。</p>
<p>一个 HTML 页面可以通过使用了特殊的 type=module 属性的 <script> 标签添加一个模块。</p>
<script type="module" src="index.js"></script>

</p><p>注意: 这个模块导入的行为就像 defer 脚本加载一样。具体可以看 efficiently load JavaScript with defer and async</p>
<p>需要特别注意的是，任何通过 type=”module” 载入的脚本会使用 严格模式 加载。</p>
<p>在这个例子中，uppercase.js 模块定义了一个 default export，因此当我们在导入它的时候，我们可以给他起一个任何我们喜欢的名字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> toUpperCase <span class="keyword">from</span> <span class="string">'./uppercase.js'</span></span><br></pre></td></tr></table></figure>
<p>同时我们可以这样使用它:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">toUpperCase(<span class="string">'test'</span>) <span class="comment">//'TEST'</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过一个绝对路径来导入模块，下面是一个引用来自其它域底下定义的模块的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> toUpperCase <span class="keyword">from</span> <span class="string">'https://flavio-es-modules-example.glitch.me/uppercase.js'</span></span><br></pre></td></tr></table></figure>
<p>下面同样是一些合法的 import语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'/uppercase.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'../uppercase.js'</span></span><br></pre></td></tr></table></figure>
<p>下面是错误的使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'uppercase.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; toUpperCase &#125; <span class="keyword">from</span> <span class="string">'utils/uppercase.js'</span></span><br></pre></td></tr></table></figure>
<p>因为这里既不是使用绝对地址，也不是使用的相对地址。</p>
<h2 id="其它的-import-export-语法"><a href="#其它的-import-export-语法" class="headerlink" title="其它的 import/export 语法"></a>其它的 import/export 语法</h2><p>我们了解了上面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> str =&gt; str.toUpperCase()</span><br></pre></td></tr></table></figure>
<p>这里生成了一个 default export。然而，你可以通过下面的语法在一个文件里面 导出 多个功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> &#123; a, b, c &#125;</span><br></pre></td></tr></table></figure>
<p>另外一个模块可以使用下面的方式 import 导入所有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure>
<p>你也可以通过解构赋值的方式仅仅 import 导出一部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br><span class="line"><span class="keyword">import</span> &#123; a, b &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure>
<p>为了方便，你还可以使用 as 重命名任何 import 的东西：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a, b <span class="keyword">as</span> two &#125; <span class="keyword">from</span> <span class="string">'module'</span></span><br></pre></td></tr></table></figure>
<p>你可以导入模块中的默认出口以及通过名称导入任何非默认的出口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br></pre></td></tr></table></figure>
<p>这是一篇关于 ES 模块的文章，可以看一下： <a href="https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html" target="_blank" rel="noopener">https://glitch.com/edit/#!/flavio-es-modules-example?path=index.html</a></p>
<h1 id="CORS-跨域资源共享"><a href="#CORS-跨域资源共享" class="headerlink" title="CORS(跨域资源共享)"></a>CORS(跨域资源共享)</h1><p>进行远程获取模块的时候是遵循 CORS 机制的。这意味着当你引用远程模块的时候，必须使用合法的 CORS 请求头来允许跨域访问（例如：Access-Control-Allow-Origin: *）。</p>
<p>对于不支持模块的浏览器应该怎么做？</p>
<p>结合 type=”module”、nomodule 一起使用：</p>
<script type="module" src="module.js"></script>
<script nomodule src="fallback.js"></script>

<h1 id="包装模块"><a href="#包装模块" class="headerlink" title="包装模块"></a>包装模块</h1><p>ES 模块是现代浏览器中的一大特性。这些特性是 ES6 规范中的一部分，要在浏览器中全部实现这些特性的路还很漫长。</p>
<p>我们现在就能使用它们！但是我们同样需要知道，有一些模块会对我们的页面性能产生性能影响。因为浏览器必须要在运行时执行它们。</p>
<p>Webpack 可能仍然会被大量使用，即使 ES 模块可以在浏览器中执行。但是语言内置这个特性对于客户端和 nodejs 在使用模块的时候是一种巨大的统一。</p>
<h1 id="新的字符串方法"><a href="#新的字符串方法" class="headerlink" title="新的字符串方法"></a>新的字符串方法</h1><p>任何字符串有了一些实例方法：</p>
<ul>
<li>repeat()</li>
<li>codePointAt()</li>
</ul>
<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h2><p>根据指定的次数重复字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Ho'</span>.repeat(<span class="number">3</span>) <span class="comment">//'HoHoHo'</span></span><br></pre></td></tr></table></figure>
<p>没有提供参数以及使用 0 作为参数的时候返回空字符串。如果给一个负数参数则会得到一个 RangeError 的错误。</p>
<h2 id="codePointAt"><a href="#codePointAt" class="headerlink" title="codePointAt()"></a>codePointAt()</h2><p>这个方法能用在处理那些需要 2 个 UTF-16 单元表示的字符上。</p>
<p>使用 charCodeAt 的话，你需要先分别得到两个 UTF-16 的编码然后结合它们。但是使用 codePointAt() 你可以直接得到整个字符。</p>
<p>下面是一个例子，中文的 “𠮷” 是由两个 UTF-16 编码组合而成的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">//d842</span></span><br><span class="line"><span class="string">"𠮷"</span>.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>) <span class="comment">//dfb7</span></span><br></pre></td></tr></table></figure>
<p>如果你将两个 unicode 字符组合起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span> <span class="comment">//"𠮷"</span></span><br></pre></td></tr></table></figure>
<p>你也可以用 codePointAt() 得到同样的结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span>.codePointAt(<span class="number">0</span>) <span class="comment">//20bb7</span></span><br></pre></td></tr></table></figure>
<p>如果你将得到的 unicode 编码组合起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"𠮷"</span> <span class="comment">//"𠮷"</span></span><br></pre></td></tr></table></figure>
<p>更多关于 Unicode 的使用方法，参考我的Unicode guide。</p>
<h1 id="新的对象方法"><a href="#新的对象方法" class="headerlink" title="新的对象方法"></a>新的对象方法</h1><p>ES2015 在 Object 类下引入了一些静态方法：</p>
<ul>
<li>Object.is() 确定两个值是不是同一个</li>
<li>Object.assign() 用来浅拷贝一个对象</li>
<li>Object.setPrototypeOf 设置一个对象的原型</li>
</ul>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>这个方法用来帮助比较对象的值：</p>
<p>使用方式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(a, b)</span><br></pre></td></tr></table></figure>
<p>返回值在下列情况之外一直是 false：</p>
<p>a 和 b 是同一个对象<br>a 和 b 是相等的字符串(用同样的字符组合在一起的字符串是相等的)<br>a 和 b 是相等的数字<br>a 和 b 都是 undefined, null, NaN, true 或者都是 false<br>0 和 -0 在 JavaScript 里面是不同的值, 所以对这种情况要多加小心（例如在比较之前，使用 + 一元操作符将所有值转换成 +0）。</p>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>在 ES2015 版本中引入，这个方法拷贝所有给出的对象中的可枚举的自身属性到另一个对象中。</p>
<p>这个 API 的基本用法是创建一个对象的浅拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> copied = <span class="built_in">Object</span>.assign(&#123;&#125;, original)</span><br></pre></td></tr></table></figure>
<p>作为浅拷贝，值会被复制，对象则是拷贝其引用（不是对象本身），因此当你修改了源对象的一个属性值，这个修改也会在拷贝出的对象中生效，因为内部引用的对象是相同的。:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> original = &#123;</span><br><span class="line">  name:<span class="string">'Fiesta'</span>,</span><br><span class="line">  car:&#123;</span><br><span class="line">    color:<span class="string">'blue'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> copied = <span class="built_in">Object</span>.assign(&#123;&#125;, original)</span><br><span class="line">original.name = <span class="string">'Focus'</span></span><br><span class="line">original.car.color = <span class="string">'yellow'</span></span><br><span class="line">copied.name <span class="comment">//Fiesta</span></span><br><span class="line">copied.car.color <span class="comment">//yellow</span></span><br></pre></td></tr></table></figure>
<p>我之前提到过，源对象可以是一个或者多个:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wisePerson = &#123;</span><br><span class="line">  isWise:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foolishPerson = &#123;</span><br><span class="line">  isFoolish:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> wiseAndFoolishPerson = <span class="built_in">Object</span>.assign(&#123;&#125;, wisePerson, foolishPerson)</span><br><span class="line"><span class="built_in">console</span>.log(wiseAndFoolishPerson) <span class="comment">//&#123; isWise: true, isFoolish: true &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf()</span><br></pre></td></tr></table></figure>
<p>设置一个对象的原型。可以接受两个参数：对象以及原型。</p>
<p>使用方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br></pre></td></tr></table></figure>
<p>例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> animal = &#123;</span><br><span class="line">  isAnimal:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> mammal = &#123;</span><br><span class="line">  isMammal:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">mammal.__proto__ = animal</span><br><span class="line">mammal.isAnimal <span class="comment">//true</span></span><br><span class="line"><span class="keyword">const</span> dog = <span class="built_in">Object</span>.create(animal)</span><br><span class="line">dog.isAnimal  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.isMammal)  <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(dog, mammal)</span><br><span class="line">dog.isAnimal <span class="comment">//true</span></span><br><span class="line">dog.isMammal <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h1 id="展开操作符"><a href="#展开操作符" class="headerlink" title="展开操作符"></a>展开操作符</h1><p>你可以展开一个数组、一个对象甚至是一个字符串，通过使用展开操作符 …。</p>
<p>让我们以数组来举例，给出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>你可以使用下面的方式创建出一个新的数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = [...a, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>你也可以像下面这样创建一个数组的拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c = [...a]</span><br></pre></td></tr></table></figure>
<p>这中方式对于对象仍然有效。使用下面的方式克隆一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> newObj = &#123; ...oldObj &#125;</span><br></pre></td></tr></table></figure>
<p>用在字符串上的时候，展开操作符会以字符串中的每一个字符创建一个数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hey = <span class="string">'hey'</span></span><br><span class="line"><span class="keyword">const</span> arrayized = [...hey] <span class="comment">// ['h', 'e', 'y']</span></span><br></pre></td></tr></table></figure>
<p>这个操作符有一些非常有用的应用。其中最重要的一点就是以一种非常简单的方式使用数组作为函数参数的能力：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="function">(<span class="params">foo, bar</span>) =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">f(...a)</span><br></pre></td></tr></table></figure>
<p>（在之前的语法规范中，你只能通过 f.apply(null, a) 的方式来实现，但是这种方式不是很友好和易读。）</p>
<p>剩余参数（rest element）在和数组解构（array destructuring）搭配使用的时候非常有用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure>
<p>下面是展开元素 （spread elements）:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> a + b + c + d + e</span><br><span class="line"><span class="keyword">const</span> sum = sum(...numbers)</span><br></pre></td></tr></table></figure>
<p>ES2018 引入了 剩余属性 ，同样的操作符但是只能用在对象上。</p>
<h1 id="剩余属性（Rest-properties）"><a href="#剩余属性（Rest-properties）" class="headerlink" title="剩余属性（Rest properties）:"></a>剩余属性（Rest properties）:</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; first, second, ...others &#125; = &#123;</span><br><span class="line">  first:<span class="number">1</span>,</span><br><span class="line">  second:<span class="number">2</span>,</span><br><span class="line">  third:<span class="number">3</span>,</span><br><span class="line">  fourth:<span class="number">4</span>,</span><br><span class="line">  fifth:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">second <span class="comment">// 2</span></span><br><span class="line">others <span class="comment">// &#123; third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>
<p>属性展开（Spread properties）允许我们结合跟在 … 操作符之后对象的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = &#123; first, second, ...others &#125;</span><br><span class="line">items <span class="comment">//&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p>一个 Set 数据结构允许我们在一个容器里面增加数据。</p>
<p>一个 Set 是一个对象或者基础数据类型（strings、numbers或者booleans）的集合，你可以将它看作是一个 Map，其中值作为映射键，map 值始终为 true。</p>
<h2 id="初始化一个-Set"><a href="#初始化一个-Set" class="headerlink" title="初始化一个 Set"></a>初始化一个 Set</h2><p>Set 可以通过下面的方式初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure>
<h2 id="向-Set-中添加一项"><a href="#向-Set-中添加一项" class="headerlink" title="向 Set 中添加一项"></a>向 Set 中添加一项</h2><p>你可以使用 add 方法向 Set 中添加项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.add(<span class="string">'one'</span>)</span><br><span class="line">s.add(<span class="string">'two'</span>)</span><br></pre></td></tr></table></figure>
<p>Set 仅会存贮唯一的元素，因此多次调用 s.add(‘one’) 不会重复添加新的元素。</p>
<p>你不可以同时向 set 中加入多个元素。你需要多次调用 add() 方法。</p>
<h2 id="检查元素是否在-set-中"><a href="#检查元素是否在-set-中" class="headerlink" title="检查元素是否在 set 中"></a>检查元素是否在 set 中</h2><p>我们可以通过下面的方式检查元素是否在 set 中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.has(<span class="string">'one'</span>) <span class="comment">//true</span></span><br><span class="line">s.has(<span class="string">'three'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="从-set-中删除一个元素："><a href="#从-set-中删除一个元素：" class="headerlink" title="从 set 中删除一个元素："></a>从 set 中删除一个元素：</h2><p>使用 delete() 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.delete(<span class="string">'one'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="确定-set-中元素的数量"><a href="#确定-set-中元素的数量" class="headerlink" title="确定 set 中元素的数量"></a>确定 set 中元素的数量</h2><p>使用 size 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.size</span><br></pre></td></tr></table></figure>
<h2 id="删除-set-中的全部元素"><a href="#删除-set-中的全部元素" class="headerlink" title="删除 set 中的全部元素"></a>删除 set 中的全部元素</h2><p>使用 clear() 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.clear()</span><br></pre></td></tr></table></figure>
<h2 id="对-set-进行迭代"><a href="#对-set-进行迭代" class="headerlink" title="对 set 进行迭代"></a>对 set 进行迭代</h2><p>使用 keys() 或者 values() 方法 - 它们等价于下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>entries() 方法返回一个迭代器，你可以这样使用它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> i = s.entries()</span><br><span class="line"><span class="built_in">console</span>.log(i.next())</span><br></pre></td></tr></table></figure>
<p>调用 i.next() 将会以 { value, done = false } 对象的形式返回每一个元素，直到迭代结束，这时 done 是 true。</p>
<p>你也可以调用 set 的 forEach() 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">s.forEach(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br></pre></td></tr></table></figure>
<p>或者你就直接使用 for..of 循环吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用一些初始值初始化一个 set</p>
<p>你可以使用一些值初始化一个 set：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<h2 id="将-set-转换为一个数组"><a href="#将-set-转换为一个数组" class="headerlink" title="将 set 转换为一个数组"></a>将 set 转换为一个数组</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...s.keys()]</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">const</span> a = [...s.values()]</span><br></pre></td></tr></table></figure>
<h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>一个 WeakSet 是一个特殊的 Set.</p>
<p>在 set 中，元素不会被 gc（垃圾回收）。一个 weakSet 让它的所有元素都是可以被 gc 的。weakSet 中的每个键都是一个对象。当这个对象的引用消失的时候，对应的值就可以被 gc 了。</p>
<p>下面是主要的不同点：</p>
<h3 id="WeakSet-不可迭代"><a href="#WeakSet-不可迭代" class="headerlink" title="WeakSet 不可迭代"></a>WeakSet 不可迭代</h3><p>你不能清空 weakSet 中的所有元素<br>不能够得到 weakSet 的大小</p>
<p>一个 weakSet 通常是在框架级别的代码中使用，仅仅暴露了下面的方法：</p>
<ul>
<li>add()</li>
<li>has()</li>
<li>delete()</li>
</ul>
<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p>一份map结构的数据允许我们建立数据和key的关系</p>
<h2 id="在ES6之前"><a href="#在ES6之前" class="headerlink" title="在ES6之前"></a>在ES6之前</h2><p>在引入Map之前，开发者通常把对象(Object)当Map使用，把某个object或value值与指定的key进行关联:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> car = &#123;&#125;</span><br><span class="line">car[<span class="string">'color'</span>] = <span class="string">'red'</span></span><br><span class="line">car.owner = <span class="string">'Flavio'</span></span><br><span class="line"><span class="built_in">console</span>.log(car[<span class="string">'color'</span>]) <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(car.color) <span class="comment">//red</span></span><br><span class="line"><span class="built_in">console</span>.log(car.owner) <span class="comment">//Flavio</span></span><br><span class="line"><span class="built_in">console</span>.log(car[<span class="string">'owner'</span>]) <span class="comment">//Flavio</span></span><br></pre></td></tr></table></figure>
<h2 id="引入Map之后"><a href="#引入Map之后" class="headerlink" title="引入Map之后"></a>引入Map之后</h2><p>ES6引入了Map数据结构，它为我们处理这种数据结构提供了一种合适的工具</p>
<h3 id="Map的初始化"><a href="#Map的初始化" class="headerlink" title="Map的初始化:"></a>Map的初始化:</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br></pre></td></tr></table></figure>
<h3 id="添加条目到Map中"><a href="#添加条目到Map中" class="headerlink" title="添加条目到Map中"></a>添加条目到Map中</h3><p>你可以通过set()方法把条目设定到map中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.set(<span class="string">'color'</span>, <span class="string">'red'</span>)</span><br><span class="line">m.set(<span class="string">'age'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="通过key值从map中获取条目"><a href="#通过key值从map中获取条目" class="headerlink" title="通过key值从map中获取条目"></a>通过key值从map中获取条目</h3><p>你可以通过get()方法从map中取出条目:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> color = m.get(<span class="string">'color'</span>)</span><br><span class="line"><span class="keyword">const</span> age = m.get(<span class="string">'age'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="通过key值从map中删除条目"><a href="#通过key值从map中删除条目" class="headerlink" title="通过key值从map中删除条目"></a>通过key值从map中删除条目</h3><p>使用delete()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.delete(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="从map中删除所有条目"><a href="#从map中删除所有条目" class="headerlink" title="从map中删除所有条目"></a>从map中删除所有条目</h3><p>使用clear()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">m.clear()</span><br></pre></td></tr></table></figure>
<h3 id="通过key值检查map中是否含有某个条目"><a href="#通过key值检查map中是否含有某个条目" class="headerlink" title="通过key值检查map中是否含有某个条目"></a>通过key值检查map中是否含有某个条目</h3><p>使用has()方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hasColor = m.has(<span class="string">'color'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="获取map中的条目数量"><a href="#获取map中的条目数量" class="headerlink" title="获取map中的条目数量"></a>获取map中的条目数量</h3><p>使用 size 属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> size = m.size</span><br></pre></td></tr></table></figure>
<h3 id="用value值初始化一个map"><a href="#用value值初始化一个map" class="headerlink" title="用value值初始化一个map"></a>用value值初始化一个map</h3><p>你可以用一组value来初始化一个map：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'color'</span>, <span class="string">'red'</span>], [<span class="string">'owner'</span>, <span class="string">'Flavio'</span>], [<span class="string">'age'</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>
<h3 id="Map-的key值"><a href="#Map-的key值" class="headerlink" title="Map 的key值"></a>Map 的key值</h3><p>任何值(对象，数组，字符串，数字)都可以作为一个map的value值(使用key-value键值的形式)，任何值也可以用作key，即使是object对象。</p>
<p>如果你想通过get()方法从map中获取不存在的key，它将会返回undefined</p>
<p>在真实世界中你几乎不可能找到的诡异情况</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(<span class="literal">NaN</span>, <span class="string">'test'</span>)</span><br><span class="line">m.get(<span class="literal">NaN</span>) <span class="comment">//test</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(+<span class="number">0</span>, <span class="string">'test'</span>)</span><br><span class="line">m.get(<span class="number">-0</span>) <span class="comment">//test</span></span><br></pre></td></tr></table></figure>
<h3 id="使用Iterate迭代器获取map的keys值"><a href="#使用Iterate迭代器获取map的keys值" class="headerlink" title="使用Iterate迭代器获取map的keys值"></a>使用Iterate迭代器获取map的keys值</h3><p>Map提供了keys()方法，通过该方法我们可以迭代出所有的key值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">of</span> m.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Iterate迭代器获取map的values值"><a href="#使用Iterate迭代器获取map的values值" class="headerlink" title="使用Iterate迭代器获取map的values值"></a>使用Iterate迭代器获取map的values值</h3><p>Map提供了values()方法，通过该方法我们可以迭代出所有的value值:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> m.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Iterate迭代器获取key-value组成的键值对</p>
<p>Map提供了entries()方法，通过该方法我们可以迭代出所有的键值对:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> m.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法还可以简化为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [k, v] <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将map的keys值转换为数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...m.keys()]</span><br></pre></td></tr></table></figure>
<p>将map的values值转换为数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [...m.values()]</span><br></pre></td></tr></table></figure>
<h2 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h2><p>WeakMap是一种特殊的Map</p>
<p>在一个map对象中，定义在其上数据永远不会被垃圾回收，WeakMap替而代之的是它允许在它上面定义的数据可以自由的被垃圾回收走，WeakMap的每一个key都是一个对象，当指向该对象的指针丢失，与之对应的value就会被垃圾回收走。</p>
<p>这是WeakMap的主要不同处：</p>
<ul>
<li>你不可以在WeakMap上迭代keys值和values值(或者key-value键值对)</li>
<li>你不可以从WeakMap上清除所有条目</li>
<li>你不可以获取WeakMap的大小</li>
</ul>
<p>WeakMap提供了如下几种方法，这些方法的使用和在Map中一样：</p>
<ul>
<li>get(k)</li>
<li>set(k, v)</li>
<li>has(k)</li>
<li>delete(k)</li>
</ul>
<p>关于WeakMap的用例不如Map的用例那么明显，你可能永远也不会在哪里会用到它，但从实际出发，WeakMap可以构建不会干扰到垃圾回收机制的内存敏感性缓存，还可以满足封装的严谨性及信息的隐藏性需求。</p>
<h1 id="Generators生成器"><a href="#Generators生成器" class="headerlink" title="Generators生成器"></a>Generators生成器</h1><p>Generators是一种特殊的函数，它能够暂停自身的执行并在一段时间后再继续运行，从而允许其它的代码在此期间运行(有关该主题的详细说明，请参阅完整的“javascript生成器指南”)。</p>
<p>Generators的代码决定它必须等待，因此它允许队列中的其它代码运行，并保留“当它等待的事情”完成时恢复其操作的权力。</p>
<p>所有这一切都是通过一个简单的关键字“yield`”完成的。当生成器包含该关键字时，将停止执行。</p>
<p>generator生成器可以包含许多yield关键字，从而使自己能多次停止运行，它是由*function关键字标识(不要将其与C、C++或Go等低级语言中使用的取消指针引用操作符混淆)。</p>
<p>Generators支持JavaScript中全新的编程范式，包括：</p>
<p>在generator运行时支持双向通信<br>不会“冻结”长期运行在程序中的while循环</p>
<p>这里有一个解释generator如何工作的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">calculator</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> doubleThat = <span class="number">2</span> * (<span class="keyword">yield</span> (input / <span class="number">2</span>))</span><br><span class="line">  <span class="keyword">var</span> another = <span class="keyword">yield</span> (doubleThat)</span><br><span class="line">  <span class="keyword">return</span> (input * doubleThat * another)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先初始化它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> calc = calculator(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>然后我们在generator中开始进行iterator迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">calc.next()</span><br></pre></td></tr></table></figure>
<p>第一个迭代器开始了迭代，代码返回如下object对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">false</span></span><br><span class="line">  value:<span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体过程如下：代码运行了函数，并把input=10传入到生成器构造函数中，该函数一直运行直到抵达yield，并返回yield输出的内容: input / 2 = 5，因此，我们得到的值为5，并告知迭代器还没有done(函数只是暂停了)。</p>
<p>在第二个迭代处，我们输入7：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">calc.next(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>
<p>然后我们得到了结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">false</span></span><br><span class="line">  value:<span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7被作为doubleThat的值，注意：你可能会把input/2作为输入参数，但这只是第一次迭代的返回值。现在我们忽略它，使用新的输入值7，并将其乘以2.</p>
<p>然后，我们得到第二个yield的值，它返回doubleThat，因此返回值为14。</p>
<p>在下一个，也是最后一个迭代器，我们输入100</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">calc.next(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>这样我们得到:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  done:<span class="literal">true</span></span><br><span class="line">  value:<span class="number">14000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当迭代器完成时(没有更多的yield关键字)，我们返回input doubleThat another，这相当于10 14100。</p>
<p>这些都是在2015年的ES2015引入的特性，现在我们深入了解下ES2016，它的作用域范围更小。</p>
<h1 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes()"></a>Array.prototype.includes()</h1><p>该特性引入了一种更简洁的语法，同来检查数组中是否包含指定元素。</p>
<p>对于ES6及更低版本，想要检查数组中是否包含指定元素，你不得不使用indexOf方法，它检查数组中的索引，如果元素不存在，它返回-1，由于-1被计算为true，你需对其进行取反操作，例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="number">1</span>,<span class="number">2</span>].indexOf(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not found'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过ES7引入的新特性，我们可以如此做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (![<span class="number">1</span>,<span class="number">2</span>].includes(<span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Not found'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求幂运算符"><a href="#求幂运算符" class="headerlink" title="求幂运算符"></a>求幂运算符</h1><p>求幂运算符**相当于Math.pow()方法，但是它不是一个函数库，而是一种语言机制：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">4</span>, <span class="number">2</span>) == <span class="number">4</span> ** <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>对于需要进行密集数学运算的程序来说，这个特性是个很好的增强，在很多语言中，**运算符都是标准(包括Python、Ruby、MATLAB、Perl等其它多种语言)。</p>
<p>这些都是2016年引入的特性，现在让我们进入2017年。</p>
<h1 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h1><p>字符串填充的目的是给字符串添加字符，以使其达到指定长度。</p>
<p>ES2017引入了两个String方法：padStart()和padEnd()。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">padStart(targetLength [, padString])</span><br><span class="line">padEnd(targetLength [, padString])</span><br></pre></td></tr></table></figure>
<p>使用例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values()</span><br></pre></td></tr></table></figure>
<p>该方法返回一个数组，数组包含了对象自己的所有属性，使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.values(person) <span class="comment">// ['Fred', 87]</span></span><br></pre></td></tr></table></figure>
<p>Object.values()也可以作用于数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Fred'</span>, <span class="string">'Tony'</span>]</span><br><span class="line"><span class="built_in">Object</span>.values(people) <span class="comment">// ['Fred', 'Tony']</span></span><br><span class="line"><span class="built_in">Object</span>.entries()</span><br></pre></td></tr></table></figure>
<p>该方法返回一个数组，数组包含了对象自己的所有属性键值对，是一个[key, value]形式的数组，使用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(person) <span class="comment">// [['name', 'Fred'], ['age', 87]]</span></span><br></pre></td></tr></table></figure>
<p>Object.entries()也可以作用于数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [<span class="string">'Fred'</span>, <span class="string">'Tony'</span>]</span><br><span class="line"><span class="built_in">Object</span>.entries(people) <span class="comment">// [['0', 'Fred'], ['1', 'Tony']]</span></span><br></pre></td></tr></table></figure>
<h1 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h1><p>该方法返回自己(非继承)的所有属性描述符，JavaScript中的任何对象都有一组属性，每个属性都有一个描述符，描述符是属性的一组属性(attributes)，由以下部分组成：</p>
<ul>
<li>value: 熟悉的value值</li>
<li>writable: 属性是否可以被更改</li>
<li>get: 属性的getter函数, 当属性读取时被调用</li>
<li>set: 属性的setter函数, 当属性设置值时被调用</li>
<li>configurable: 如果为false, 不能删除该属性，除了它的value值以为，也不能更改任何属性。</li>
<li>enumerable: 该属性是否能枚举</li>
<li>Object.getOwnPropertyDescriptors(obj)接受一个对象，并返回一个带有描述符集合的对象。</li>
</ul>
<h1 id="In-what-way-is-this-useful"><a href="#In-what-way-is-this-useful" class="headerlink" title="In what way is this useful?"></a>In what way is this useful?</h1><p>ES6给我们提供了Object.assign()方法，它从一个一个或多个对象中复制所有可枚举的属性值，并返回一个新对象。</p>
<p>但是，这也存在着一个问题，因为它不能正确的复制一个具有非默认属性值的属性。</p>
<p>如果对象只有一个setter，那么它就不会正确的复制到一个新对象上，使用Object.assign()进行如下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person1 = &#123;</span><br><span class="line">    <span class="keyword">set</span> name(newName) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(newName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将不会起作用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person2 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(person2, person1)</span><br></pre></td></tr></table></figure>
<p>但这将会起作用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person3 = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(person3)</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(person1))</span><br></pre></td></tr></table></figure>
<p>通过一个简单的console控制台，你可以查看以下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person1.name = <span class="string">'x'</span></span><br><span class="line"><span class="string">"x"</span></span><br><span class="line">person2.name = <span class="string">'x'</span></span><br><span class="line">person3.name = <span class="string">'x'</span></span><br><span class="line"><span class="string">"x"</span></span><br></pre></td></tr></table></figure>
<p>person2没有setter，它没能复制进去，对象的浅复制限定也出现在Object.create()方法中。</p>
<h1 id="尾逗号"><a href="#尾逗号" class="headerlink" title="尾逗号"></a>尾逗号</h1><p>该特性允许在函数定义时有尾逗号，在函数使用时可以有尾逗号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">var1, var2,</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">doSomething(<span class="string">'test2'</span>, <span class="string">'test2'</span>,)</span><br></pre></td></tr></table></figure>
<p>该改变将鼓励开发者停止“在一行开始时写逗号”的丑陋习惯</p>
<h1 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h1><p>JavaScript在很短的时间内从回调函数进化到Promise函数(ES2015)，并自从ES2017以来，异步JavaScript的async/wait语法变得更加简单。 异步函数是Promise和generator的结合，基本上，它是比Promise更高级的抽象，我再重复一般：async/await是基于Promise建立的</p>
<h2 id="为什么要引入async-await"><a href="#为什么要引入async-await" class="headerlink" title="为什么要引入async/await"></a>为什么要引入async/await</h2><p>它减少了围绕promise的引用，并打破了Promise — “不要打断链式调用”的限制。</p>
<p>当Promise在ES2015中引入时，它的本意是来解决异步代码的问题，它也确实做到了，但在ES2015和ES2017间隔的这两年中，大家意识到：Promise不是解决问题的终极方案。</p>
<p>Promise是为了解决著名的回调地狱而被引入的，但它本身也带来了使用复杂性和语法复杂性。</p>
<p>Promise是很好的原生特性，围绕着它开发人员可以探索出更好的语法，因此当时机成熟后，我们得到了async函数</p>
<p>async函数使代码看起来像是同步函数一样，但其背后却是异步和非堵塞的。</p>
<h2 id="它如何工作"><a href="#它如何工作" class="headerlink" title="它如何工作"></a>它如何工作</h2><p>一个async函数会返回一个promise，如下例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomethingAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你想要调用该函数时，你在前面加上了一个wait，这样调用就会被停止，直到该promise进行resolve或reject，需注意的是：外层函数必须定义为async，这是例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> doSomethingAsync())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个上手示例"><a href="#一个上手示例" class="headerlink" title="一个上手示例"></a>一个上手示例</h2><p>这是一个使用async/await进行异步函数的简单示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomethingAsync = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">await</span> doSomethingAsync())</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Before'</span>)</span><br><span class="line">doSomething()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'After'</span>)</span><br></pre></td></tr></table></figure>
<p>上面的代码将会在浏览器的console中打印出如下结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Before</span><br><span class="line">After</span><br><span class="line">I did something <span class="comment">//after 3s</span></span><br></pre></td></tr></table></figure>
<h2 id="关于-Promise"><a href="#关于-Promise" class="headerlink" title="关于 Promise"></a>关于 Promise</h2><p>将 async 关键字标记在任何函数上，意味着这个函数都将返回一个 Promise，即使这个函数没有显式的返回，它在内部也会返回一个 Promise，这就是下面这份代码有效的原因：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aFunction = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) <span class="comment">// This will alert 'test'</span></span><br></pre></td></tr></table></figure>
<p>下面的例子也一样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aFunction = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'test'</span>)</span><br><span class="line">&#125;</span><br><span class="line">aFunction().then(alert) <span class="comment">// This will alert 'test'</span></span><br></pre></td></tr></table></figure>
<p>###更易于阅读的代码</p>
<p>正如上述的例子，我们将它与普通回调函数或链式函数进行比较，我们的代码看起来非常的简单。</p>
<p>这是一个很简单的例子，当代码足够复杂时，它会产生更多的收益。</p>
<p>例如，使用 Promise 来获取 JSON 资源并解析它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstUserData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">'/users.json'</span>) <span class="comment">// get users list</span></span><br><span class="line">    .then(<span class="function"><span class="params">response</span> =&gt;</span> response.json()) <span class="comment">// parse JSON</span></span><br><span class="line">    .then(<span class="function"><span class="params">users</span> =&gt;</span> users[<span class="number">0</span>]) <span class="comment">// pick first user</span></span><br><span class="line">    .then(<span class="function"><span class="params">user</span> =&gt;</span> fetch(<span class="string">`/users/<span class="subst">$&#123;user.name&#125;</span>`</span>)) <span class="comment">// get user data</span></span><br><span class="line">    .then(<span class="function"><span class="params">userResponse</span> =&gt;</span> response.json()) <span class="comment">// parse JSON</span></span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>
<p>这是使用 async/await 实现相同功能的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getFirstUserData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(<span class="string">'/users.json'</span>) <span class="comment">// get users list</span></span><br><span class="line">  <span class="keyword">const</span> users = <span class="keyword">await</span> response.json() <span class="comment">// parse JSON</span></span><br><span class="line">  <span class="keyword">const</span> user = users[<span class="number">0</span>] <span class="comment">// pick first user</span></span><br><span class="line">  <span class="keyword">const</span> userResponse = <span class="keyword">await</span> fetch(<span class="string">`/users/<span class="subst">$&#123;user.name&#125;</span>`</span>) <span class="comment">// get user data</span></span><br><span class="line">  <span class="keyword">const</span> userData = <span class="keyword">await</span> user.json() <span class="comment">// parse JSON</span></span><br><span class="line">  <span class="keyword">return</span> userData</span><br><span class="line">&#125;</span><br><span class="line">getFirstUserData()</span><br></pre></td></tr></table></figure>
<h2 id="串行多个异步功能"><a href="#串行多个异步功能" class="headerlink" title="串行多个异步功能"></a>串行多个异步功能</h2><p>async 函数非常容易，并且它的语法比 Promise 更易读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promiseToDoSomething = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="string">'I did something'</span>), <span class="number">10000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> watchOverSomeoneDoingSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> something = <span class="keyword">await</span> promiseToDoSomething()</span><br><span class="line">  <span class="keyword">return</span> something + <span class="string">' and I watched'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> something = <span class="keyword">await</span> watchOverSomeoneDoingSomething()</span><br><span class="line">  <span class="keyword">return</span> something + <span class="string">' and I watched as well'</span></span><br><span class="line">&#125;</span><br><span class="line">watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印结果:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">I did something and I watched and I watched <span class="keyword">as</span> well</span><br></pre></td></tr></table></figure>
<h2 id="更简单的调试"><a href="#更简单的调试" class="headerlink" title="更简单的调试"></a>更简单的调试</h2><p>调试 Promise 就很困难，因为调试器无法跨越异步代码，但调试 async/await 就非常的简单，调试器会像调试同步代码一样来处理它。</p>
<h2 id="共享内存和原子"><a href="#共享内存和原子" class="headerlink" title="共享内存和原子"></a>共享内存和原子</h2><p>WebWorkers 可以在浏览器中创建多线程程序。</p>
<p>它们通过事件的方式来传递消息，从 ES2017 开始，你可以使用 SharedArrayBuffer 在每一个 Worker 中和它们的创建者之间共享内存数组.</p>
<p>由于不知道写入内存部分需要多长的周期来广播，因此在读取值时，任何类型的写入操作都会完成，Atomics 可以避免竞争条件的发生。</p>
<p>关于它的更多细节可以在proposal中找到。</p>
<p>这是 ES2017，接下来我将介绍 ES2018 的功能。</p>
<p>Rest/Spread Properties</p>
<p>ES2015 引入了解构数组的方法，当你使用时：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[first, second, ...others] = numbers</span><br></pre></td></tr></table></figure>
<p>and 展开参数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> sum = <span class="function">(<span class="params">a, b, c, d, e</span>) =&gt;</span> a + b + c + d + e</span><br><span class="line"><span class="keyword">const</span> sum = sum(...numbers)</span><br></pre></td></tr></table></figure>
<p>ES2018 为对象引入了同样的功能。</p>
<p>解构:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; first, second, ...others &#125; = &#123; <span class="attr">first</span>:<span class="number">1</span>, <span class="attr">second</span>:<span class="number">2</span>, <span class="attr">third</span>:<span class="number">3</span>, <span class="attr">fourth</span>:<span class="number">4</span>, <span class="attr">fifth</span>:<span class="number">5</span> &#125;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">second <span class="comment">// 2</span></span><br><span class="line">others <span class="comment">// &#123; third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>
<p>展开属性 允许通过组合在展开运算符之后传递的对象属性而创建新对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = &#123; first, second, ...others &#125;</span><br><span class="line">items <span class="comment">//&#123; first: 1, second: 2, third: 3, fourth: 4, fifth: 5 &#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="异步迭代器"><a href="#异步迭代器" class="headerlink" title="异步迭代器"></a>异步迭代器</h2><p>for-await-of 允许你使用异步可迭代对象做为循环迭代：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> line <span class="keyword">of</span> readLines(filePath)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(line)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为它使用的了 await，因此你只能在 async 函数中使用它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally()</span><br></pre></td></tr></table></figure>
<p>当一个 Promise 是 fulfilled 时，它会一个接一个的调用 then。</p>
<p>如果在这个过程中发生了错误，则会跳过 then 而执行 catch。</p>
<p>而 finally() 允许你运行一些代码，无论是成功还是失败：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fetch(<span class="string">'file.json'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> data.json())</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error))</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'finished'</span>))</span><br></pre></td></tr></table></figure>
<h1 id="正则表达式改进"><a href="#正则表达式改进" class="headerlink" title="正则表达式改进"></a>正则表达式改进</h1><p>ES2018 对正则表达式引入了许多改进，这些都可以在 <a href="https://flaviocopes.com/javascript-regular-expressions/" target="_blank" rel="noopener">https://flaviocopes.com/javascript-regular-expressions/</a> 上找到。</p>
<p>以下是关于 ES2018 正则表达式改进的具体补充：</p>
<p>RegExp lookbehind assertions: 根据前面的内容匹配字符串</p>
<p>这是一个 lookahead: 你可以使用 ?= 来匹配字符串，后面跟随一个特定的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/Roger(?=Waters)/</span><br><span class="line">/Roger(?=Waters)/.test(<span class="string">'Roger is my dog'</span>) <span class="comment">//false</span></span><br><span class="line">/Roger(?=Waters)/.test(<span class="string">'Roger is my dog and Roger Waters is a famous musician'</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>?! 可以执行逆操作，如果匹配的字符串是no而不是在此后跟随特定的子字符串的话：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/Roger(?!Waters)/</span><br><span class="line">/Roger(?!Waters)/.test(<span class="string">'Roger is my dog'</span>) <span class="comment">//true</span></span><br><span class="line">/Roger(?!Waters)/.test(<span class="string">'Roger Waters is a famous musician'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>Lookaheads 使用 ?= Symbol，它们已经可以用了。</p>
<p>Lookbehinds, 是一个新功能使用?&lt;=.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;=Roger) Waters/</span><br><span class="line">/(?&lt;=Roger) Waters/.test(<span class="string">'Pink Waters is my dog'</span>) <span class="comment">//false</span></span><br><span class="line">/(?&lt;=Roger) Waters/.test(<span class="string">'Roger is my dog and Roger Waters is a famous musician'</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>如果一个 lookbehind 是否定，那么使用 ?&gt;!:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/(?&lt;!Roger) Waters/</span><br><span class="line">/(?&lt;!Roger) Waters/.test(<span class="string">'Pink Waters is my dog'</span>) <span class="comment">//true</span></span><br><span class="line">/(?&lt;!Roger) Waters/.test(<span class="string">'Roger is my dog and Roger Waters is a famous musician'</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>Unicode属性转义 p{…} and P{…}</p>
<p>在正则表达式模式中，你可以使用 d 来匹配任意的数字，s 来匹配任意不是空格的字符串，w 来匹配任意字母数字字符串，以此类推。</p>
<p>This new feature extends this concept to all Unicode characters introducing p{} and is negation P{}.</p>
<p>这个新功能扩展了unicode字符，引入了 p{} 来处理</p>
<p>任何 unicode 字符都有一组属性，例如 script 确认语言，ASCII 是一个布尔值用于检查 ASCII 字符。你可以将此属性方在() 中，正则表达式将来检查是否为真。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'abc'</span>)   <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC@'</span>)  <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII&#125;+$/u.test(<span class="string">'ABC🙃'</span>) <span class="comment">//❌</span></span><br></pre></td></tr></table></figure>
<p>ASCII_Hex_Digit 是另一个布尔值，用于检查字符串是否包含有效的十六进制数字：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'0123456789ABCDEF'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;ASCII_Hex_Digit&#125;+$/u.test(<span class="string">'h'</span>)                <span class="comment">//❌</span></span><br></pre></td></tr></table></figure>
<p>此外，还有很多其它的属性。你可以在()中添加它们的名字来检查它们，包括 Uppercase, Lowercase, White_Space, Alphabetic, Emoji等等：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^p&#123;Lowercase&#125;$/u.test(<span class="string">'h'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;Uppercase&#125;$/u.test(<span class="string">'H'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;Emoji&#125;+$/u.test(<span class="string">'H'</span>)   <span class="comment">//❌</span></span><br><span class="line">/^p&#123;Emoji&#125;+$/u.test(<span class="string">'🙃🙃'</span>) <span class="comment">//✅</span></span><br></pre></td></tr></table></figure>
<p>除了二进制属性外，你还可以检查任何 unicode 字符属性以匹配特定的值，在这个例子中，我检查字符串是用希腊语还是拉丁字母写的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/^p&#123;Script=Greek&#125;+$/u.test(<span class="string">'ελληνικά'</span>) <span class="comment">//✅</span></span><br><span class="line">/^p&#123;Script=Latin&#125;+$/u.test(<span class="string">'hey'</span>) <span class="comment">//✅</span></span><br></pre></td></tr></table></figure>
<p>阅读<a href="https://github.com/tc39/proposal-regexp-unicode-property-escapes">https://github.com/tc39/proposal-regexp-unicode-property-escapes</a> 获取使用所有属性的详细信息。</p>
<p>Named capturing groups<br>In ES2018 a capturing group can be assigned to a name, rather than just being assigned a slot in the result array:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/(?&lt;year&gt;d&#123;4&#125;)-(?&lt;month&gt;d&#123;2&#125;)-(?&lt;day&gt;d&#123;2&#125;)/</span></span><br><span class="line"><span class="keyword">const</span> result = re.exec(<span class="string">'2015-01-02'</span>)</span><br><span class="line"><span class="comment">// result.groups.year === '2015';</span></span><br><span class="line"><span class="comment">// result.groups.month === '01';</span></span><br><span class="line"><span class="comment">// result.groups.day === '02';</span></span><br></pre></td></tr></table></figure>
<p>The s flag for regular expressions<br>The s flag, short for single line, causes the . to match new line characters as well. Without it, the dot matches regular characters but not the new line:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/hi.welcome/.test(<span class="string">'hi</span></span><br><span class="line"><span class="string">welcome'</span>) <span class="comment">// false</span></span><br><span class="line">/hi.welcome/s.test(<span class="string">'hi</span></span><br><span class="line"><span class="string">welcome'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="ESNext"><a href="#ESNext" class="headerlink" title="ESNext"></a>ESNext</h1><h2 id="什么是-ESNext"><a href="#什么是-ESNext" class="headerlink" title="什么是 ESNext"></a>什么是 ESNext</h2><p>ESNext 是一个始终指向下一个版本 JavaScript 的名称。</p>
<p>当前的 ECMAScript 版本是 ES2018，它于2018年6月被发布。</p>
<p>历史上 JavaScript 标准化的版本都是在夏季被发布，因此我们可以预期 ECMAScript 2019 将于 2019 年的夏季被发布。</p>
<p>所以在编写本文时 ES2018 已经被发布，因此 ESNext 指的是 ES2019。</p>
<p>ECMAScript 标准的提案是分阶段组织的，第一到第三阶段属于功能性的孵化，第四阶段的功能才最终确定为新标准的一部分。</p>
<p>在编写本文时主要浏览器都实现了第四阶段大部分的功能，因此我将在本文中介绍它们。</p>
<p>其中一些变化主要在内部使用，但知道发生了什么这也很好。</p>
<p>第三阶段还有一些其它功能，可能会在接下来的几个月内升级到第四阶段，你可以在这个 Github 仓库中查看它们：<a href="https://github.com/tc39/proposals。">https://github.com/tc39/proposals。</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.&#123;flat,flatMap&#125;</span><br></pre></td></tr></table></figure>
<p>flat() 是一个新的数组实例方法，它可以将多维数组转化成一维数组。</p>
<p>例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, <span class="string">'Wolf'</span>]].flat()</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br></pre></td></tr></table></figure>
<p>默认情况下它只能将二维的数组转化成一维的数组，但你可以添加一个参数来确定要展开的级别，如果你将这个参数设置为 Infinity 那么它将展开无限的级别到一维数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat()</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', [ 'Wolf' ] ]</span></span><br><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br><span class="line">[<span class="string">'Dog'</span>, [<span class="string">'Sheep'</span>, [<span class="string">'Wolf'</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">//[ 'Dog', 'Sheep', 'Wolf' ]</span></span><br></pre></td></tr></table></figure>
<p>如果你熟悉数组的 map 方法，那么你就知道使用它可以对数组的每个元素执行一个函数。</p>
<p>flatMap() 是一个新的数组实例方法，它将 flat() 和 map 结合了起来，当你期望在map函数中做一些处理时这非常有用，同时又希望结果如同 flat ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="string">'My dog'</span>, <span class="string">'is awesome'</span>].map(<span class="function"><span class="params">words</span> =&gt;</span> words.split(<span class="string">' '</span>))</span><br><span class="line"><span class="comment">//[ [ 'My', 'dog' ], [ 'is', 'awesome' ] ]</span></span><br><span class="line">[<span class="string">'My dog'</span>, <span class="string">'is awesome'</span>].flatMap(<span class="function"><span class="params">words</span> =&gt;</span> words.split(<span class="string">' '</span>))</span><br><span class="line"><span class="comment">//[ 'My', 'dog', 'is', 'awesome' ]</span></span><br></pre></td></tr></table></figure>
<h1 id="Optional-catch-binding"><a href="#Optional-catch-binding" class="headerlink" title="Optional catch binding"></a>Optional catch binding</h1><p>有时候我们并不需要将参数绑定到 try/catch 中。</p>
<p>在以前我们不得不这样做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">//handle error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使我们从来没有通过 e 来分析错误，但现在我们可以简单的省略它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">//handle error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.fromEntries()</span><br></pre></td></tr></table></figure>
<p>Objects have an entries() method, since ES2017.<br>从 ES2017 开始 Object将有一个 entries() 方法。</p>
<p>它将返回一个包含所有对象自身属性的数组的数组，如[key, value]：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="built_in">Object</span>.entries(person) <span class="comment">// [['name', 'Fred'], ['age', 87]]</span></span><br></pre></td></tr></table></figure>
<p>ES2019 引入了一个新的 Object.fromEntries() 方法，它可以从上述的属性数组中创建一个新的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>:<span class="string">'Fred'</span>, <span class="attr">age</span>:<span class="number">87</span> &#125;</span><br><span class="line"><span class="keyword">const</span> entries = <span class="built_in">Object</span>.entries(person)</span><br><span class="line"><span class="keyword">const</span> newPerson = <span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"></span><br><span class="line">person !== newPerson <span class="comment">//true</span></span><br><span class="line"><span class="built_in">String</span>.prototype.&#123;trimStart,trimEnd&#125;</span><br></pre></td></tr></table></figure>
<p>这些功能已经被 v8/Chrome 实现了近一年的时间，它将在 ES2019 中实现标准化。</p>
<p>trimStart()</p>
<p>删除字符串首部的空格并返回一个新的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing '</span>.trimStart() <span class="comment">//'Testing '</span></span><br><span class="line"><span class="string">'Testing'</span>.trimStart() <span class="comment">//'Testing'</span></span><br><span class="line">trimEnd()</span><br></pre></td></tr></table></figure>
<p>删除字符串尾部的空格并返回一个新的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'Testing'</span>.trimEnd() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="string">' Testing'</span>.trimEnd() <span class="comment">//' Testing'</span></span><br><span class="line"><span class="string">' Testing '</span>.trimEnd() <span class="comment">//' Testing'</span></span><br><span class="line"><span class="string">'Testing '</span>.trimEnd() <span class="comment">//'Testing'</span></span><br><span class="line"><span class="built_in">Symbol</span>.prototype.description</span><br></pre></td></tr></table></figure>
<p>现在你可以使用 description 来获取 Symbol 的值，而不必使用 toString() 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testSymbol = <span class="built_in">Symbol</span>(<span class="string">'Test'</span>)</span><br><span class="line">testSymbol.description <span class="comment">// 'Test'</span></span><br></pre></td></tr></table></figure>
<h1 id="JSON-improvements"><a href="#JSON-improvements" class="headerlink" title="JSON improvements"></a>JSON improvements</h1><p>在此之前 JSON 字符串中不允许使用分隔符（）和分隔符（）。</p>
<p>使用 JSON.parse 时，这些字符会导致一个 SyntaxError 错误，但现在它们可以正确的解析并如 JSON 标准定义的那样。</p>
<h2 id="Well-formed-JSON-stringify"><a href="#Well-formed-JSON-stringify" class="headerlink" title="Well-formed JSON.stringify()"></a>Well-formed JSON.stringify()</h2><p>修复 JSON.stringify() 在处理 UTF-8 code points (U+D800 to U+DFFF)。</p>
<p>在修复之前，调用 JSON.stringify() 将返回格式错误的 Unicode 字符，如（a “�”)。</p>
<p>现在你可以安全放心的使用 JSON.stringify() 转成字符串，也可以使用 JSON.parse() 将它转换回原始表示的形态。</p>
<h2 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h2><p>函数总会有一个 toString 方法，它将返回一个包含函数代码的字符串。</p>
<p>ES2019 对返回值做了修改，以避免剥离注释和其它字符串（如：空格），将更准确的表示函数的定义。</p>
<p>If previously we had</p>
<p>以前也许我们这样过：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">this</span> <span class="title">is</span> <span class="title">bar</span> */ <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>当时的行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bar.toString() <span class="comment">//'function bar() &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在的行为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bar.toString(); <span class="comment">// 'function /* this is bar */ bar () &#123;&#125;'</span></span><br></pre></td></tr></table></figure>
<p>总结一下，我希望这篇文章可以帮助你了解一些最新的 JavaScript 以及我们在 2019 年即将看见的内容。</p>
<h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p>原文地址：<a href="https://medium.freecodecamp.org/es5-to-esnext-heres-every-feature-added-to-javascript-since-2015-d0c255e13c6e" target="_blank" rel="noopener">https://medium.freecodecamp.org/es5-to-esnext-heres-every-feature-added-to-javascript-since-2015-d0c255e13c6e</a></p>
]]></content>
      <categories>
        <category>技术文章</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
